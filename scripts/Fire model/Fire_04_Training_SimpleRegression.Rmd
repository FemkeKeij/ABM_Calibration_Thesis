---
title: "Fire_03_Calibration_SimpleRegression"
author: "Femke Keij S2647168"
date: "2023-02-14"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preliminaries
Clear working directory & set random seed:
```{r}
rm(list = ls(all = TRUE))

set.seed(42)
```

Packages used:
```{r}
# for importing / working with tidy data
library(tidyverse)

# for ggplot
library(directlabels)
library(patchwork)
library(ggbeeswarm)
```

Source files for error computation and plotting functions:
```{r}
source('scripts/Fire model/Fire_Functions.R')
```

Read in the data:
```{r}
# training data
fire_training <- read_csv('data/training/fire_training.csv')
```

# Fitting
Fit a linear regression to predict density and a logistic regression to predict directions. We use 5-fold cross-validation to assess predictive performance.

There are multiple versions here:
- full time series, 10 timesteps, 20 timesteps, endpoints only (I'm leaving out the 50 timesteps here since the simulations are mostly too short for that)
- runs summarised or not
- data without noise, data with output noise, data with output and temporal noise
There are no variations with different sample sizes or sampling methods here, since I sampled the full parameter space for this model.

To perform:
1) select relevant sample size, sampling method, summarisation of runs, noise, and type of datapoints
2) select relevant data columns, include combination_number, ticks, outputs, and input parameters
3) pivot wider to make each time step a column
4) feed to fitting function

```{r}
data <- fire_training %>%
  filter(noise == 'noise',
         datapoints == 'timesteps',
         ticks %% 10 == 0) %>%
  select(ticks, density, directions,
         burn_percentage, mean_burn_percentage,
         mean_burn, min_burn, sd_burn, trend_burn) %>%
  pivot_wider(names_from = ticks,
              values_from = burn_percentage) %>%
  # I'm only looking at the first 200 timesteps here, because otherwise too much data drops out. I'll have to think about how I want to approach this.
  select(1:20) %>%
  drop_na()
```


```{r}
FireSimpleRegressionFitting <- function(data,
                                      sample_size,
                                      sample_method,
                                      summarised_runs,
                                      noise,
                                      datapoints){
  # data: the data frame containing the input parameters as well as the relevant outputs
  # sample_size, sample_method, summarised_runs, noise, datapoints: as in training data frame
  
  # create the folds
  flds <- createFolds(1:nrow(data),
                      k = 5, list = TRUE, returnTrain = FALSE)

  # to store the results
  results_df <- tibble(fold = numeric(),
                       variable = character(),
                       perc_correct = numeric(),
                       perc_correct_cat = numeric(),
                       RMSE = numeric(),
                       NRMSE = numeric(),
                       point_pred = numeric())
  
  # set directions 4 to 0 and 8 to 1 (eases interpretation of logistic regression)
  data <- data %>%
    mutate(directions = ifelse(directions == 4, 0, 1))

  # for each cross-validation fold
  for(i in 1:5){
    # remove the test fold to create the training data
    dat_train <- data %>%
      filter(!row_number() %in% unlist(flds[i]))
  
    # obtain the test fold
    dat_test <- data %>%
      filter(row_number() %in% unlist(flds[i]))
  
    # train the linear & logistic regressions
    fit_lm_density <- lm(formula = density ~ . - directions,
                         data = dat_train)
    fit_glm_directions <- glm(formula = directions ~ . - density,
                              data = dat_train)
    
    # predict the density & directions in the left-out fold
    predict_density <- predict.lm(fit_lm_density,
                                  newdata = dat_test,
                                  interval = 'prediction')
    predict_directions <- predict.glm(fit_glm_directions,
                                      newdata = dat_test,
                                      type = 'response')
    # correct predictions for directions to 4 vs. 8
    for(j in 1:length(predict_directions)){
      predict_directions[j] <- ifelse(predict_directions[j] <= 0.5,
                                      4, 8)
    }
    
    # compute mean input parameter in training data for
    # point prediction computation
    mean_density <- mean(dat_train$density)
  
    # add error computations
    predictions <- tibble(density_pred = predict_density,
                          density_true = dat_test$density,
                          directions_pred = predict_directions,
                          directions_true = dat_test$directions)
    
    results_df <- results_df %>%
      add_row(ComputeErrors(predictions,
                            fold = i,
                            mean_density = mean_density))
  }
  
  # compute mean of each statistic over the 5 folds
  results_df <- results_df %>%
    group_by(variable)%>%
    summarise_all(mean) %>%
    select(- fold) %>%
    # add the experiment info to the df
    add_column(sample_size = sample_size,
               sample_method = sample_method,
               summarised_runs = summarised_runs,
               noise = noise,
               datapoints = datapoints)
  
  return(results_df)
}


LinearRegressionFitting <- function(data,
                                    formula_density,
                                    formula_directions){
  # create tibble to store data
  results <- tibble(CV_fold = numeric(nrow(data)),
                    true_density = numeric(nrow(data)),
                    true_directions = numeric(nrow(data)),
                    pred_density = numeric(nrow(data)),
                    pred_directions = numeric(nrow(data)))
  
  # create a matrix that relates the rows the data to the cross-validation fold they are in
  indices <- sample(nrow(data))
  folds <- cbind(indices, cut(indices, breaks = 5, labels = FALSE))
  colnames(folds) <- c('indices', 'fold')
  folds <- as_tibble(folds)
  
  # for every cross-validation fold
  for(i in 1:5){
    test_indices <- folds %>%
      filter(fold == i) %>%
      select(indices)
    # separate the training and test data
    training_dat <- data %>%
      slice(-test_indices)
    test_dat <- data %>%
      slice(test_indices)
    
    # train the linear & logistic regressions
    fir_lm_density <- lm(data = training_dat,
                         formula = formula_density)
    fit_glm_directions <- glm(data = training_dat,
                              formula = formula_directions)
    
    # predict the density & directions
    predict_density <- predict.lm(fit_lm_density,
                                     newdata = test_dat,
                                     interval = 'prediction')
    predict_directions <- predict.glm(fit_glm_directions,
                                      newdata = test_dat,
                                      type = 'response')
    
    
  }  
}
```

Run for each combination:
- full time series, 10 timesteps, 20 timesteps, endpoints only (I'm leaving out the 50 timesteps here since the simulations are mostly too short for that)
- runs summarised or not
- data without noise, data with output noise, data with output and temporal noise
```{r}
# endpoints, summarised runs, no noise
data <- fire_training %>%
  filter(summarised_runs == 'summarised',
         noise == 'clean',
         datapoints == 'endpoints') %>%
  LinearRegressionFitting(formula_density =
                            'density ~ burn_percentage',
                          formula_directions =
                            'directions ~ burn_percentage')

# endpoints, summarised runs, output noise
results_ <- fire_training %>%
  filter(summarised_runs == 'summarised',
         noise == 'noise',
         datapoints == 'endpoints') %>%
  LinearRegressionFitting(formula_density =
                            'density ~ burn_percentage_noise',
                          formula_directions =
                            'directions ~ burn_percentage_noise')


```

```{r}
LinearRegressionFitting <- function(ticks = FALSE){
  # table to store all output
  length_tib <- sum(nrow(fire_test) * length(n))
  regression_results <- tibble(direction_true = numeric(length_tib),
                              direction_pred = numeric(length_tib),
                              density_true = numeric(length_tib),
                              density_pred = numeric(length_tib),
                              density_pred_lwr = numeric(length_tib),
                              density_pred_upr = numeric(length_tib),
                              burn_true = numeric(length_tib),
                              burn_pred = numeric(length_tib),
                              n = numeric(length_tib),
                              ticks_included = numeric(length_tib))
  regression_fits <- tibble(density_fit = numeric(),
                            direction_fit = numeric(),
                            n = numeric())
  # vector to store mean density in each training sample
  # (to calculate point prediction performance later on)
  density_means <- numeric(length(n))

  count <- 1
  
  # for each sample size
  for(i in 1:length(n)){
    # sample training set
    ind_sample <- sample(1:nrow(fire_train), size = n[i])
    fire_train_sub <- fire_train[ind_sample, ]
    # calculate and save mean density in training set
    density_means[i] <- mean(fire_train_sub$density)
    
    if(ticks == TRUE){
      # linear regression to predict density when ticks are included
      fit_lm_density <- lm(data = fire_train_sub,
                               formula = 'density ~ burn_percentage + directions + ticks')
      # logistic regression to predict directions when ticks are included
      fit_glm_directions <- glm(data = fire_train_sub,
                                    formula = 'directions ~ burn_percentage + density + ticks',
                                    family = binomial(link = 'logit'))
      
    } else{
      # linear regression to predict density when ticks are excluded
      fit_lm_density <- lm(data = fire_train_sub,
                               formula = 'density ~ burn_percentage + directions')
      # logistic regression to predict directions when ticks are excluded
      fit_glm_directions <- glm(data = fire_train_sub,
                                      formula = 'directions ~ burn_percentage + density',
                                      family = binomial(link = 'logit'))
    }
    # predict density in test data using fitted regression
    # include prediction interval to compute coverage later on
    predict_lm_density <- predict.lm(fit_lm_density,
                                             newdata = fire_test,
                                     interval = 'prediction')
    # retrieve fitted training data
    fit_lm_density <- predict.lm(fit_lm_density)
    # predict direction in test data using fitted regression
    predict_glm_directions <- predict.glm(fit_glm_directions,
                                                  newdata = fire_test,
                                                  type = 'response')
    # retrieve fitted training data
    fit_glm_directions <- predict.glm(fit_glm_directions)
    # correct the predicted directions from probabilities to '4' and '8'
    # to match test data
    for(k in 1:nrow(fire_test)){
      if(predict_glm_directions[k] < 0.5){
        predict_glm_directions[k] <- 4
      } else{
        predict_glm_directions[k] <- 8
      }
    }
    # correct the fitted directions to '4' and '8'
    for(k in 1:nrow(fire_train_sub)){
      if(fit_glm_directions[k] < 0){
        fit_glm_directions[k] <- 4
      } else{
        fit_glm_directions[k] <- 8
      }
    }
    
    # store the fitted data
    add_dat <- tibble(density_fit = fit_lm_density,
                  direction_fit = fit_glm_directions,
                  n = n[i])
    regression_fits <- rbind(regression_fits, add_dat)
    
    # for each instance of the test data
    for(j in 1:nrow(fire_test)){
      # find an instance in the training data that matches the directions
      # and density
      ind <- which(fire_train$density == round(predict_lm_density[j,1]) &
                     fire_train$directions ==
                     predict_glm_directions[j])
      if(length(ind) > 1){
        ind <- sample(ind, size = 1)
      }
      # find predicted burn percentage based on training data
      burn_pred <- fire_train$burn_percentage[ind]
      
      # store all results in table
      regression_results$direction_true[count] <- fire_test$directions[j]
      regression_results$direction_pred[count] <-
        predict_glm_directions[j]
      regression_results$density_true[count] <- fire_test$density[j]
      regression_results$density_pred[count] <- predict_lm_density[j,1]
      regression_results$density_pred_lwr[count] <-
        predict_lm_density[j,2]
      regression_results$density_pred_upr[count] <-
        predict_lm_density[j,3]
      regression_results$burn_true[count] <- fire_test$burn_percentage[j]
      regression_results$burn_pred[count] <- burn_pred
      regression_results$n[count] <- n[i]
      regression_results$ticks_included[count] <- if(ticks){'yes'}else{'no'}
      
      count <- count + 1
    }
  }
  
  # correct format of direction_true variable
  regression_results %>%
    mutate(direction_true = replace(direction_true, direction_true == 1, 4),
         direction_true = replace(direction_true, direction_true == 2, 8)) ->
    regression_results
  
  # return table with results, density means, and fitted regression values
  return(list(regression_results, density_means, regression_fits))
}
```

```{r}
# fit regressions with ticks
regression_results_ticks <- LinearRegressionFitting(ticks = TRUE)
density_means_ticks <- regression_results_ticks[[2]]
regression_fits_ticks <- regression_results_ticks[[3]]
regression_results_ticks <- regression_results_ticks[[1]]

# fit regressions without ticks
regression_results_noticks <- LinearRegressionFitting(ticks = FALSE)
density_means_noticks <- regression_results_noticks[[2]]
regression_fits_noticks <- regression_results_noticks[[3]]
regression_results_noticks <- regression_results_noticks[[1]]
```

```{r}
# run error calculations
regression_errors_ticks <- ComputeErrors(regression_results_ticks,
                                         ticks = TRUE,
                                         density_means_ticks,
                                         pred_int_included = TRUE)
regression_errors_noticks <- ComputeErrors(regression_results_noticks,
                                           ticks = FALSE,
                                           density_means_noticks,
                                           pred_int_included = TRUE)
```

Merge results
```{r}
regression_results <- rbind(regression_results_noticks,
                            regression_results_ticks)
write_csv(regression_results,
          'data/processed/fire_regression_results.csv')

regression_errors <- rbind(regression_errors_noticks, regression_errors_ticks)
write_csv(regression_errors,
          'data/processed/fire_regression_errors.csv')
```

# Plots
```{r}
# regression_results <- read_csv('data/processed/fire_regression_results.csv')

# regression_errors <- read_csv('data/processed/fire_regression_errors.csv')
```

## Errors
Fix results and errors data frames:
```{r}
regression_results <- regression_results %>%
  mutate(n = factor(n),
         direction_true = factor(direction_true),
         direction_pred = factor(direction_pred),
         direction_correct = (direction_pred == direction_true))

regression_errors <- regression_errors %>%
  mutate(n = factor(n))
```
### Predicted vs. true
Predicted vs. true for density, directions, and burn percentage
```{r}
p1 <- PlotPredTrueDensity(regression_results, n = 1584)
p2 <- PlotPredTrueDirection(regression_results, n = 1584)
p3 <- PlotPredTrueBurn(regression_results, n = 1584)

p1 / p2 / p3
```
Predicted vs. true density (largest sample size only):
```{r}
PlotPredTrueDensity(regression_results, n = 1584)

ggsave('figures/fire_regression_predtrue_density.pdf')
```
Confusion matrix for predicted vs. true directions:
```{r}
PlotPredTrueDirection(regression_results, n = 1584)

ggsave('figures/fire_regression_predtrue_direction.pdf')
```
Predicted vs. true burn percentage (largest sample size only):
```{r}
PlotPredTrueBurn(regression_results, n = 1584)

ggsave('figures/fire_regression_predtrue_burn.pdf')
```
### Parameters
% correctly predicted parameters (density & directions):
```{r}
PlotPercCorrectParams(regression_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_regression_perc_correct.pdf')
```
RMSE, NRMSE, point prediction performance, and coverage for density parameter:
```{r}
PlotErrorsDensity(regression_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_regression_density_metrics.pdf')
```
F1, kappa score, and MCC for directions:
```{r}
PlotErrorsDirections(regression_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_regression_directions_metrics.pdf')
```
### Outcome variable
RMSE for burn percentage:
```{r}
PlotRMSEOut(regression_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_regression_RMSE_burn.pdf')
```

## Model fit
Fitted regression lines (smallest and largest sample size):
Linear regression for density
```{r}
RegressionLinePlot <- function(sample = 1, ticks = TRUE){
  if(ticks){
    formula <- 'density ~ burn_percentage + directions + ticks'
    subtitle <- 'with ticks'
  } else{
    formula <- 'density ~ burn_percentage + directions'
    subtitle <- 'without ticks'
  }
  
  subtitle <- paste(subtitle, ' sample size ', n[sample])
  
  ind_sample <- sample(1:nrow(fire_train), size = n[sample])
  fire_train_sub <- fire_train[ind_sample, ]
  
  fire_train_sub %>%
    ggplot(mapping = aes(x = burn_percentage, y = density,
                         colour = directions)) +
    geom_point() +
    geom_line(data = fortify(lm(data = fire_train_sub,
                                formula = formula)),
              aes(x = burn_percentage, y = .fitted)) +
    labs(x = '% burned trees at last tick',
         y = 'tree density (%)',
         subtitle = subtitle) +
    theme_minimal() +
    coord_flip() -> returnplot

  return(returnplot)
}

p1 <- RegressionLinePlot(sample = 1, ticks = TRUE)
p2 <- RegressionLinePlot(sample = 1, ticks = FALSE)
p3 <- RegressionLinePlot(sample = 9, ticks = TRUE)
p4 <- RegressionLinePlot(sample = 9, ticks = FALSE)

p1 + p2 + p3 + p4 +
  plot_layout(guides = 'collect') +
  plot_annotation(tag_levels = 'A') & 
  theme(plot.tag = element_text(size = 8))

ggsave('figures/fire_regression_fit.pdf')
```

Logistic regression for directions (only largest training sample size)
```{r}
fit_glm_ticks <- glm(data = fire_train,
               formula = 'directions ~ burn_percentage + density + ticks',
               family = binomial(link = 'logit'))
plot_df_ticks <- augment(fit_glm_ticks, type.predict = 'response')

p1 <- plot_df_ticks %>%
  ggplot(mapping = aes(x = density, y = .fitted,
                       colour = directions)) +
  geom_point(size = 0.5) +
  labs(x = 'tree density',
       y = 'probability number of directions is 8',
       colour = 'true number \n of directions') +
  geom_hline(yintercept = 0.5,
             linetype = 'dashed',
             colour = 'darkgreen') +
  theme_minimal() +
  theme(panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = 'lightgrey', fill = NA)) +
  annotate(geom = 'text',
           x = 17, y = 0.25,
           label = 'directions \n classified \n as 4',
           size = 3) +
  annotate(geom = 'text',
           x = 83, y = 0.75,
           label = 'directions \n classified \n as 8',
           size = 3) +
  ylim(c(0, 1)) +
  ggtitle('ticks')

fit_glm_noticks <- glm(data = fire_train,
               formula = 'directions ~ burn_percentage + density',
               family = binomial(link = 'logit'))
plot_df_noticks <- augment(fit_glm_noticks, type.predict = 'response')

p2 <- plot_df_noticks %>%
  ggplot(mapping = aes(x = density, y = .fitted,
                       colour = directions)) +
  geom_point(size = 0.5) +
  labs(x = 'tree density',
       y = 'probability number of directions is 8',
       colour = 'true number \n of directions') +
  geom_hline(yintercept = 0.5,
             linetype = 'dashed',
             colour = 'darkgreen') +
  theme_minimal() +
  theme(panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = 'lightgrey', fill = NA)) +
  annotate(geom = 'text',
           x = 17, y = 0.25,
           label = 'directions \n classified \n as 4',
           size = 3) +
  annotate(geom = 'text',
           x = 83, y = 0.75,
           label = 'directions \n classified \n as 8',
           size = 3) +
  ylim(c(0, 1)) +
  ggtitle('no ticks')

patch <- p1 + p2 +
    plot_layout(guides = 'collect') +
    plot_annotation(tag_levels = 'A') & 
    theme(plot.tag = element_text(size = 8)) &
    xlab(NULL)
  
wrap_elements(panel = patch) +
  labs(tag = 'tree density (%)') +
  theme(plot.tag = element_text(size = rel(1)),
        plot.tag.position = 'bottom')

ggsave('figures/fire_logistic_fit.pdf')
```