---
title: "Fire_03_Calibration_Regression"
author: "Femke Keij S2647168"
date: "2023-02-14"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preliminaries
Clear working directory & set random seed:
```{r}
rm(list = ls(all = TRUE))

set.seed(42)
```

Packages used:
```{r}
# for piecewise linear regression
library(segmented)

# for splines
library(splines)

# for importing / working with tidy data
library(tidyverse)

# for ggplot
library(directlabels)
library(patchwork)
```

Read in the data:
```{r}
# complete output data
fire_output <- read_csv('data/raw/fire_output.csv')

# training data
fire_train <- read_csv(
  'data/processed/fire_train.csv')
fire_train$directions <- as.factor(fire_train$directions)

# test data
fire_test <- read_csv(
  'data/processed/fire_test.csv')
fire_test$directions <- as.factor(fire_test$directions)
```

Functions to use:
```{r}
#source('scripts/methods/linear-regression-functions.R')
```

# Regression

## Linear regression
Use the functions from the **Linear regression functions.R** file to get the errors for different training sample sizes

Random samples:
5, 10, 20, 30, 40, 50, 60, 70, and 80 $%$ of the total parameter space.
```{r}
N <- nrow(fire_output)
# range of (training) sample sizes to work with
n <- c(0.05 * N, 0.1 * N, 0.2 * N, 0.3 * N, 0.4 * N, 0.5 * N,
       0.6 * N, 0.7 * N, nrow(fire_train))
```

```{r}
LinearRegressionFitting <- function(ticks = FALSE){
  length_tib <- sum(nrow(fire_test) * length(n))
  regression_results <- tibble(direction_true = numeric(length_tib),
                              direction_pred = numeric(length_tib),
                              density_true = numeric(length_tib),
                              density_pred = numeric(length_tib),
                              density_pred_lwr = numeric(length_tib),
                              density_pred_upr = numeric(length_tib),
                              burn_true = numeric(length_tib),
                              burn_pred = numeric(length_tib),
                              n = numeric(length_tib),
                              ticks_included = numeric(length_tib))
  density_means <- numeric(length(n))

  count <- 1

  for(i in 1:length(n)){
    ind_sample <- sample(1:nrow(fire_train), size = n[i])
    fire_train_sub <- fire_train[ind_sample, ]
    density_means[i] <- mean(fire_train_sub$density)
    
    if(ticks == TRUE){
      fit_lm_density <- lm(data = fire_train_sub,
                               formula = 'density ~ burn_percentage + directions + ticks')
      fit_glm_directions <- glm(data = fire_train_sub,
                                    formula = 'directions ~ burn_percentage + density + ticks',
                                    family = binomial(link = 'logit'))
      
    } else{
      fit_lm_density <- lm(data = fire_train_sub,
                               formula = 'density ~ burn_percentage + directions')
      
      fit_glm_directions <- glm(data = fire_train_sub,
                                      formula = 'directions ~ burn_percentage + density',
                                      family = binomial(link = 'logit'))
    }
    
    predict_lm_density <- predict.lm(fit_lm_density,
                                             newdata = fire_test,
                                     interval = 'prediction')
    
    predict_glm_directions <- predict.glm(fit_glm_directions,
                                                  newdata = fire_test,
                                                  type = 'response')
    for(k in 1:nrow(fire_test)){
      if(predict_glm_directions[k] < 0.5){
        predict_glm_directions[k] <- 4
      } else{
        predict_glm_directions[k] <- 8
      }
    }
    
    for(j in 1:nrow(fire_test)){
      ind <- which(fire_train$density == round(predict_lm_density[j,1]) &
                     fire_train$directions ==
                     predict_glm_directions[j])
      if(length(ind) > 1){
        ind <- sample(ind, size = 1)
      }
      burn_pred <- fire_train$burn_percentage[ind]
      regression_results$direction_true[count] <- fire_test$directions[j]
      regression_results$direction_pred[count] <-
        predict_glm_directions[j]
      regression_results$density_true[count] <- fire_test$density[j]
      regression_results$density_pred[count] <- predict_lm_density[j,1]
      regression_results$density_pred_lwr[count] <-
        predict_lm_density[j,2]
      regression_results$density_pred_upr[count] <-
        predict_lm_density[j,3]
      regression_results$burn_true[count] <- fire_test$burn_percentage[j]
      regression_results$burn_pred[count] <- burn_pred
      regression_results$n[count] <- n[i]
      regression_results$ticks_included[count] <- if(ticks){'yes'}else{'no'}
      
      count <- count + 1
    }
  }
  
  # correct format of direction_true variable
  regression_results %>%
    mutate(direction_true = replace(direction_true, direction_true == 1, 4),
         direction_true = replace(direction_true, direction_true == 2, 8)) ->
    regression_results
  
  return(list(regression_results, density_means))
}
```

```{r}
regression_results_ticks <- LinearRegressionFitting(ticks = TRUE)
density_means_ticks <- regression_results_ticks[[2]]
regression_results_ticks <- regression_results_ticks[[1]]
regression_results_noticks <- LinearRegressionFitting(ticks = FALSE)
density_means_noticks <- regression_results_noticks[[2]]
regression_results_noticks <- regression_results_noticks[[1]]
```

```{r}
RegressionErrors <- function(regression_results, ticks = FALSE,
                             density_means){
  
  merge(regression_results, as_tibble(cbind(n, density_means)),
        by = c('n')) %>%
    group_by(n) %>%
    summarise(perc_correct = sum(direction_true ==
                                   direction_pred &
                                   density_true == round(density_pred))
                / nrow(fire_test),
              perc_density_correct = sum(density_true ==
                                         round(density_pred)) /
                nrow(fire_test),
              perc_direction_correct = sum(direction_true ==
                                           direction_pred) /
                nrow(fire_test),
              perc_correct_cat = sum(density_pred >=
                                       density_true - 5 &
                                       density_pred <=
                                       density_true + 5) /
                nrow(fire_test),
              RMSE = sqrt(sum((density_pred - density_true)^2))
                /nrow(fire_test),
              NRMSE = (sqrt(sum((density_pred -
                                   density_true)^2))
                     / nrow(fire_test)) / sd(density_true),
              point_pred_performance = 1 - 
                sum(sqrt((density_pred - density_true)^2)) /
                sum(sqrt((density_true - density_means)^2)),
              coverage = sum(density_true <= density_pred_upr &
                               density_true >= density_pred_lwr) /
                nrow(fire_test)) ->
    regression_errors
  
  regression_errors$ticks_included <- 
    if(ticks == TRUE){'yes'} else{'no'}

  return(regression_errors)
}
```

```{r}
regression_errors_ticks <- RegressionErrors(regression_results_ticks,
                                            ticks = TRUE,
                                            density_means_ticks)
regression_errors_noticks <- RegressionErrors(regression_results_noticks,
                                            ticks = FALSE,
                                            density_means_noticks)
```

Merge results
```{r}
regression_results <- rbind(regression_results_noticks, regression_results_ticks)
``` 

```{r}
regression_errors <- rbind(regression_errors_noticks, regression_errors_ticks)
```

# Plots
Predicted vs. true density (largest sample size only):
```{r}
regression_results$n <- as.factor(regression_results$n)
regression_results$direction_true <-
  as.factor(regression_results$direction_true)
regression_results$direction_pred <-
  as.factor(regression_results$direction_pred)

supp_labs <- c('without ticks', 'with ticks')
names(supp_labs) <- c('no', 'yes')

regression_results %>%
  filter(n == 1584) %>%
  ggplot(mapping = aes(x = density_pred, y = density_true,
                       colour = direction_true,
                       shape = direction_pred)) +
  facet_grid(. ~ ticks_included,
             labeller = labeller(ticks_included = supp_labs)) +
  geom_point() +
  theme_minimal() +
  labs(x = 'predicted density',
       y = 'true density',
       colour = 'True number of directions',
       shape = 'Predicted number of directions') +
  theme(panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank())

ggsave('figures/fire_regression_pred_vs_true.pdf')
```

% of predictions that are correct
```{r}
regression_errors$n <- as.factor(regression_errors$n)

regression_errors %>%
  filter(n == c(99, 792, 1584)) %>%
  ggplot(mapping = aes(x = n, y = perc_correct,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(y = 'density & direction',
       fill = 'Ticks included') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p1

regression_errors %>%
  filter(n == c(99, 792, 1584)) %>%
  ggplot(mapping = aes(x = n, y = perc_density_correct,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(y = 'density',
       fill = 'Ticks included') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p2

regression_errors %>%
  filter(n == c(99, 792, 1584)) %>%
  ggplot(mapping = aes(x = n, y = perc_direction_correct,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(y = 'direction',
       fill = 'Ticks included') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p3

regression_errors %>%
  filter(n == c(99, 792, 1584)) %>%
  ggplot(mapping = aes(x = n, y = perc_correct_cat,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(y = 'density within \n 10% of true density',
       fill = 'Ticks included') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p4

p1 + p2 + p3 + p4 +
  plot_layout(guides = 'collect') +
  plot_annotation(tag_levels = 'A',
                  title = '% correctly predicted') & 
  theme(plot.tag = element_text(size = 8))

ggsave('figures/fire_regression_perc_correct.pdf')
```

RMSE, NRMSE & point prediction performance
```{r}
regression_errors %>%
  ggplot(mapping = aes(x = n, y = RMSE,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(fill = 'Ticks included') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p1

regression_errors %>%
  ggplot(mapping = aes(x = n, y = NRMSE,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(fill = 'Ticks included') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p2

regression_errors %>%
  ggplot(mapping = aes(x = n, y = point_pred_performance,
                       fill = ticks_included)) +
  geom_bar(stat = 'identity',
           position = position_dodge()) +
  labs(fill = 'Ticks included',
       y = 'point prediction performance') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) -> p3

p1 + p2 + p3 +
  plot_layout(guides = 'collect') +
  plot_annotation(tag_levels = 'A') & 
  theme(plot.tag = element_text(size = 8))

ggsave('figures/fire_regression_RMSE.pdf')
```

#####PREVIOUS CODE
Plot the fit with the smallest and largest sample size:
```{r}
fire_train %>%
  ggplot(mapping = aes(x = density, y = burn_percentage,
                       colour = directions)) +
  geom_point() +
  geom_line(data = fortify(linear_regression_fit[[1]]),
            aes(x = density, y = .fitted)) -> p1

fire_train %>%
  ggplot(mapping = aes(x = density, y = burn_percentage,
                       colour = directions)) +
  geom_point() +
  geom_line(data = fortify(linear_regression_fit[[9]]),
            aes(x = density, y = .fitted)) -> p2

p1 + p2
```

Calculate some error rates:
```{r}

``` 

```{r}
linear_reg_RMSE <- rep(NA, length(n))
linear_reg_performance <- list()

for(i in 1:length(n)){
  fit <- LinearRegFitting(n = n[i],
                   training = fire_train,
                   formula = 'burn_percentage ~ density + direction')
  
  linear_reg_RMSE[i] <- LinearRegError(fit = fit,
                                           test = fire_test,
                                           y = 'burn_percentage')
  
  linear_reg_performance[[i]] <- CalcPerformance(fit = fit,
                                                 training = fire_train,
                                                 test = fire_test)
}
```

Plot the errors
```{r}
as.data.frame(cbind(n, linear_reg_RMSE)) %>%
  ggplot(aes(x = n, y = linear_reg_RMSE)) +
  geom_point() +
  labs(x = "training sample size", y = "RMSE between model outcome in test data and predicted outcome") -> p1


linear_reg_performance <- cbind(n,
                                matrix(unlist(linear_reg_performance),
                                       nrow = length(n),
                                       ncol = 2,
                                       byrow = TRUE))
colnames(linear_reg_performance) <- c("n", "density", "direction")

as.data.frame(linear_reg_performance) %>%
  ggplot() +
  geom_point(aes(x = n, y = density), colour = 'green') +
  geom_point(aes(x = n, y = direction), colour = 'red') +
  labs(x = "training sample size", y = "performance") -> p2

linear_reg_error_plot <- p1 + p2 + 
  plot_layout(ncol = 1) +
  plot_annotation(title = "Error progression in simple linear regression for different sample sizes",
                  subtitle = "green points for density, red points for direction")

linear_reg_error_plot
```

### Illustrate the errors for simple linear regression
```{r}
# use functions from `Linear regression functions.R` file
# create plot for a number of sample sizes
p10 <- LinearRegPlottingFire(n = 10, training = fire_train)
p50 <- LinearRegPlottingFire(n = 50, training = fire_train)
p100 <- LinearRegPlottingFire(n = 100, training = fire_train)
p500 <- LinearRegPlottingFire(n = 500, training = fire_train)
p1000 <- LinearRegPlottingFire(n = 100, training = fire_train)
pfull <- LinearRegPlottingFire(n = nrow(fire_train),
                          training = fire_train)

# combine plots
linear_reg_fit_plot <- p10 + p50 + p100 + p500 + p1000 + pfull +
  # split into 2 columns
  plot_layout(ncol = 2) +
  # title & caption
  plot_annotation(title = "Mutliple linear regression fit on the Fire model for different sample sizes",
                  subtitle = "Regression fit on % burned trees ~ tree density + direction of fire spread \n")

# display plot
linear_reg_fit_plot

# SAVE PLOT

```

### Prediction intervals
Use resampling bootstrapping to obtain the prediction intervals:

200 bootstrap data sets are produced and the same linear regression is run on each one. from each regression i, their prediction beta_i S(theta*) are collected and one standardized residual e is sampled (a residual divided by the square root of one minus the hat value associated with that residual). this produces a set of 200 beta_i S(theta*) + e_i. The 95% prediction interval is then defined by 2.5 and 97.5 percentile of this set.


```{r}
# create 200 bootstrap intervals out of the training data
bootstrap_samples <- list()
for(i in 1:200){
  bootstrap_sample <- fire_train[sample(1:nrow(fire_train),
                                        size = nrow(fire_train),
                                        replace = TRUE), ]
  bootstrap_lm_fit <- lm(formula = burn_percentage ~ density + direction,
                         data = bootstrap_sample)
  density_prediction <- predict(bootstrap_lm_fit,
                                newdata = fire_test,
                                type = "terms")[1]
  res <- abs(density_prediction - fire_test[, 2])
  hat <- density_prediction * 
  hat <- hatvalues(bootstrap_lm_fit)
  st_res <- res / sqrt(1 - hat)
}
```

## Piecewise linear regression
Calculate the piecewise linear regression fit for each of the directions and each of the sample sizes
```{r}
# create data frame to store the RMSEs for each sample size and direction
piecewise_reg_errors <- bind_cols(rep(n, 2),
                                  c(rep(4, length(n)),
                                         rep(8, length(n))),
                                  rep(NA, 2 * length(n)))
colnames(piecewise_reg_errors) <- c("N", "direction", "RMSE")

for(i in 2:length(n)){
  fit4 <- PiecewiseRegFitting(n = n[i],
                             training = filter(fire_train,
                                               direction == "4"),
                             formula = "burn_percentage ~ density")
  fit8 <- PiecewiseRegFitting(n = n[i],
                              training = filter(fire_train,
                                                direction == "8"),
                              formula = "burn_percentage ~ density")
  
  piecewise_reg_errors[i] <- 
    rmse(fit4,
         data = filter(fire_test, direction == "4"))
  piecewise_reg_errors[i + length(n)] <-
    rmse(fit8, 
         data = filter(fire_test, direction == "8"))
  #piecewise_reg_errors[i] <- 
   # PiecewiseRegError(fit = fit4, 
    #                  test = filter(fire_test, direction == "4"),
     #                 y = 'burn_percentage')
  #piecewise_reg_errors[i + length(n)] <- 
   # PiecewiseRegError(fit = fit8,
    #                  test = filter(fire_test, direction == "8"),
     #                 y = 'burn_percentage')
}
```

```{r}
piecewise_fit_4 <- lm(burn_percentage ~ density,
                      data = filter(fire_train, direction == "4"))

segmented_fit_4 <- segmented(piecewise_fit_4, 
                           seg.Z = ~ density,
                           psi = 59)
```

Plot the fits
```{r}
newdat_4 <- as.data.frame(cbind(fire_four_output$density,
                 broken.line(segmented_fit_4)$fit))
newdat_8 <- as.data.frame(cbind(fire_eight_output$density,
                 broken.line(segmented_fit_8)$fit))

ggplot() +
  geom_point(data = fire_train, aes(x = density, y = burn_percentage,
                                    color = direction)) +
  geom_line(data = newdat_4, aes(x = newdat_4[, 1], y = newdat_4[, 2]),
            colour = 'red') +
  geom_line(data = newdat_8, aes(x = newdat_8[, 1], y = newdat_8[, 2]),
            colour = 'blue') +
  labs(x = "density", y = "% burned trees at last tick")
```

Calculate the error (separately for each direction)
```{r}
# predict values in the test set, using the segmented fit
predict_piecewise_4 <- predict.segmented(segmented_fit_4,
                                         newdat = filter(fire_test,
                                                         direction == "4"))
predict_piecewise_8 <- predict.segmented(segmented_fit_8,
                                         newdat = filter(fire_test,
                                                         direction == "8"))

piecewise_rmse_4 <- sqrt(mean((filter(fire_test, direction == "4")$burn_percentage - predict_piecewise_4)^2))

piecewise_rmse_8 <- sqrt(mean((filter(fire_test, direction == "8")$burn_percentage - predict_piecewise_8)^2))
```

## Splines
### Cubic spline
```{r}

```
### Smoothing spline
```{r}

```

## Elastic net regression
Fit the elastic net (training using 5-fold cross-validation):
```{r}

```