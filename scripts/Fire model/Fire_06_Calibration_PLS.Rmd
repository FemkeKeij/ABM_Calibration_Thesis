---
title: "Fire_08_Calibartion_MultipleMultivariateRegression"
author: "Femke Keij S2647168"
date: "2023-03-17"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preliminaries
Clear working directory & set random seed:
```{r}
rm(list = ls(all = TRUE))

set.seed(42)
```

Packages used:
```{r}
# for importing / working with tidy data
library(tidyverse)

# for ggplot
library(directlabels)
library(patchwork)
library(ggbeeswarm)

# for partial least squares
library(pls)
```

Functions to compute and plot errors:
```{r}
source('scripts/Fire model/Fire_Functions.R')
```

# Fitting
A function to fit a Partial Least Squares for the density and direction parameters, using 5-fold cross-validation.
```{r}
FirePLSFitting <- function(data_clean,
                       data_noise){
  # data_clean: the data frame containing the input parameters as well as the relevant outputs
  # data_noise: supply data with noise here
  
  # create the folds
  flds <- createFolds(1:nrow(data_clean),
                      k = 5, list = TRUE, returnTrain = FALSE)

  # to store the results
  results_df <- tibble(density = numeric(),
                       directions = numeric(),
                       density_pred = numeric(),
                       directions_pred = numeric(),
                       noise = character(),
                       fold = numeric())
  
  # create dummy variables to use for directions
  data_clean <- data_clean %>%
    mutate(true_four = ifelse(directions == '4', 1, 0),
           true_eight = ifelse(directions == '8', 1, 0))
  data_noise <- data_noise %>%
    mutate(true_four = ifelse(directions == '4', 1, 0),
           true_eight = ifelse(directions == '8', 1, 0))
  
  # for each cross-validation fold
  for(i in 1:5){
    # remove the test fold to create the training data
    dat_train <- data_clean %>%
      filter(!row_number() %in% unlist(flds[i]))
    
    # obtain the test fold without noise
    dat_test_clean <- data_clean %>%
        filter(row_number() %in% unlist(flds[i]))
    # obtain the test fold with noise
    dat_test_noise <- data_noise %>%
        filter(row_number() %in% unlist(flds[i]))
    
    # train the partial least squares
    fit_pls <- plsr(cbind(density, true_four, true_eight) ~
                      ., data = dat_train, validation = 'LOO',
                    scale = TRUE)
    
    # cross-validation to determine number of components
    ncomp.cv <- crossval(fit_pls)$ncomp
    
    # predict the density & directions in the left-out fold without nois
    predict_pls_clean <- predict(fit_pls,
                                 newdata = dat_test_clean,
                                 ncomp = ncomp.cv)
    # the predictions for the dummy variables can be interpreted
    # as class probabilities
    predict_pls_clean <- tibble(density_pred = 
                                  predict_pls_clean[, 1, 1],
                                direction_four =
                                  predict_pls_clean[, 2, 1],
                                direction_eight =
                                  predict_pls_clean[, 3, 1]) %>%
      mutate(directions_pred = ifelse(direction_four > direction_eight,
                                     4, 8))
    
    # predict the density & directions in the left-out fold with noise
    predict_pls_noise <- predict(fit_pls,
                                 newdata = dat_test_noise,
                                 ncomp = ncomp.cv)
    
    predict_pls_noise <- tibble(density_pred = 
                                  predict_pls_noise[, 1, 1],
                                direction_four =
                                  predict_pls_noise[, 2, 1],
                                direction_eight =
                                  predict_pls_noise[, 3, 1]) %>%
      mutate(directions_pred = ifelse(direction_four > direction_eight,
                                     4, 8))
    
    # add the predictions to the data frame
    results_new_clean <- tibble(density = dat_test_clean$density,
                          directions = dat_test_clean$directions,
                          density_pred = 
                            predict_pls_clean$density_pred,
                          directions_pred = 
                            predict_pls_clean$directions_pred,
                          fold = i,
                          noise = 'clean')
    results_new_noise <- tibble(density = dat_test_clean$density,
                                directions = dat_test_clean$directions,
                                density_pred =
                                  predict_pls_noise$density_pred,
                                directions_pred = 
                                  predict_pls_noise$directions_pred,
                                fold = i,
                                noise = 'noise')
    results_df <- results_df %>%
      add_row(results_new_clean) %>%
      add_row(results_new_noise)
  }
  
  return(results_df)
}
```

Work with this one:
```{r}
FirePLSFitting <- function(data_clean,
                       data_noise){
  # data_clean: the data frame containing the input parameters as well as the relevant outputs
  # data_noise: supply data with noise here
  
  # create the folds
  flds <- createFolds(1:nrow(data_clean),
                      k = 5, list = TRUE, returnTrain = FALSE)

  # to store the results
  results_df <- tibble(density = numeric(),
                       directions = numeric(),
                       density_pred = numeric(),
                       directions_pred = numeric(),
                       noise = character(),
                       fold = numeric())
  
  # create dummy variables to use for directions
  data_clean <- data_clean %>%
    mutate(true_four = ifelse(directions == '4', 1, 0))
  data_noise <- data_noise %>%
    mutate(true_four = ifelse(directions == '4', 1, 0))
  
  # for each cross-validation fold
  for(i in 1:5){
    # remove the test fold to create the training data
    dat_train <- data_clean %>%
      filter(!row_number() %in% unlist(flds[i]))
    
    # obtain the test fold without noise
    dat_test_clean <- data_clean %>%
        filter(row_number() %in% unlist(flds[i]))
    # obtain the test fold with noise
    dat_test_noise <- data_noise %>%
        filter(row_number() %in% unlist(flds[i]))
    
    # train the partial least squares
    fit_pls <- plsr(cbind(density, true_four) ~ . - directions,
                    data = dat_train, validation = 'LOO',
                    scale = TRUE)
    
    # cross-validation to determine number of components
    ncomp.cv <- crossval(fit_pls)$ncomp
    
    # predict the density & directions in the left-out fold without noise
    predict_pls_clean <- predict(fit_pls,
                                 newdata = dat_test_clean,
                                 ncomp = ncomp.cv)
    # the predictions for the dummy variables can be interpreted
    # as class probabilities
    predict_pls_clean <- tibble(density_pred = 
                                  predict_pls_clean[, 1, 1],
                                direction_four =
                                  predict_pls_clean[, 2, 1]) %>%
      mutate(directions_pred = ifelse(direction_four >= 0.5,
                                     4, 8))
    
    # predict the density & directions in the left-out fold with noise
    predict_pls_noise <- predict(fit_pls,
                                 newdata = dat_test_noise,
                                 ncomp = ncomp.cv)
    
    predict_pls_noise <- tibble(density_pred = 
                                  predict_pls_noise[, 1, 1],
                                direction_four =
                                  predict_pls_noise[, 2, 1]) %>%
      mutate(directions_pred = ifelse(direction_four >= 0.5,
                                     4, 8))
    
    # add the predictions to the data frame
    results_new_clean <- tibble(density = dat_test_clean$density,
                          directions = dat_test_clean$directions,
                          density_pred = 
                            predict_pls_clean$density_pred,
                          directions_pred = 
                            predict_pls_clean$directions_pred,
                          fold = i,
                          noise = 'clean')
    results_new_noise <- tibble(density = dat_test_clean$density,
                                directions = dat_test_clean$directions,
                                density_pred =
                                  predict_pls_noise$density_pred,
                                directions_pred = 
                                  predict_pls_noise$directions_pred,
                                fold = i,
                                noise = 'noise')
    results_df <- results_df %>%
      add_row(results_new_clean) %>%
      add_row(results_new_noise)
  }
  
  return(results_df)
}
```

Timesteps, not summarised
```{r}
data_time_full_clean <-
  read_csv('data/training/fire_time_full_clean.csv')
data_time_full_outputnoise <-
  read_csv('data/training/fire_time_full_outputnoise.csv')

# fit regressions
fit_data_time_full <-
  FirePLSFitting(data_time_full_clean,
                 data_noise = data_time_full_outputnoise)

# compute errors
errors_data_time_full <- 
  FireComputeErrors(fit_data_time_full,
                    sample_size = 198,
                    sample_method = 'full',
                    summarise_runs = 'full',
                    datapoints = 'timepoints')

# dataframe to store all errors
errors <- errors_data_time_full
```

Timesteps, summarised
```{r}
data_time_sum_clean <-
  read_csv('data/training/fire_time_sum_clean.csv')
data_time_sum_outputnoise <-
  read_csv('data/training/fire_time_sum_outputnoise.csv')

fit_data_time_sum <-
  FirePLSFitting(data_time_sum_clean,
                 data_noise = data_time_sum_outputnoise)

errors_data_time_sum <- 
  FireComputeErrors(fit_data_time_sum,
                    sample_size = 198,
                    sample_method = 'full',
                    summarise_runs = 'summarised',
                    datapoints = 'timepoints')

errors <- errors %>%
  add_row(errors_data_time_sum)
```

Endpoints, not summarised
```{r}
data_end_full_clean <-
  read_csv('data/training/fire_end_full_clean.csv')
data_end_full_outputnoise <-
  read_csv('data/training/fire_end_full_outputnoise.csv')

fit_data_end_full <-
  FirePLSFitting(data_end_full_clean,
                 data_noise = data_end_full_outputnoise)

errors_data_end_full <- 
  FireComputeErrors(fit_data_end_full,
                    sample_size = 198,
                    sample_method = 'full',
                    summarise_runs = 'full',
                    datapoints = 'endpoints')

errors <- errors %>%
  add_row(errors_data_end_full)
```

Endpoints, summarised
```{r}
data_end_sum_clean <- read_csv('data/training/fire_end_sum_clean.csv')
data_end_sum_outputnoise <-
  read_csv('data/training/fire_end_sum_outputnoise.csv')

fit_data_end_sum <-
  FirePLSFitting(data_end_sum_clean,
                 data_noise = data_end_sum_outputnoise)

errors_data_end_sum <- 
  FireComputeErrors(fit_data_end_sum,
                    sample_size = 198,
                    sample_method = 'full',
                    summarise_runs = 'summarised',
                    datapoints = 'endpoints')

errors <- errors %>%
  add_row(errors_data_end_sum)
```

Save results:
```{r}
errors %>%
  mutate(algorithm = 'PLS') %>%
  write_csv(file = 'data/results/fire_pls_errors.csv')
```

# Plots
```{r}
plot1 <- PlotPercCorrectParams(errors)

ggsave('figures/fire_pls_perc_correct.pdf')
```

```{r}
plot2 <- PlotErrorsDensity(errors)

ggsave('figures/fire_pls_density.pdf')
```

```{r}
plot3 <- PlotErrorsDirections(errors)

ggsave('figures/fire_pls_directions.pdf')
```

################### -------- OLD CODE ------------- #################

```{r}
# pls_results <- read_csv('data/processed/fire_partialleastsquares_results.csv')

# pls_errors <- read_csv('data/processed/fire_partialleastsquares_errors.csv')
```

## Errors


Fix results and errors data frames:
```{r}
pls_results <- pls_results %>%
  mutate(n = factor(n),
         direction_true = factor(direction_true),
         direction_pred = factor(direction_pred),
         direction_correct = (direction_pred == direction_true))

pls_errors <- pls_errors %>%
  mutate(n = factor(n))
```

### Predicted vs. true
Predicted vs. true for density, directions, and burn percentage
```{r}
p1 <- PlotPredTrueDensity(pls_results, n = 1584)
p2 <- PlotPredTrueDirection(pls_results, n = 1584)
p3 <- PlotPredTrueBurn(pls_results, n = 1584)

p1 / p2 / p3
```
Predicted vs. true density (largest sample size only):
```{r}
PlotPredTrueDensity(pls_results, n = 1584)

ggsave('figures/fire_pls_predtrue_density.pdf')
```
Confusion matrix for predicted vs. true directions:
```{r}
PlotPredTrueDirection(pls_results, n = 1584)

ggsave('figures/fire_pls_predtrue_direction.pdf')
```
Predicted vs. true burn percentage (largest sample size only):
```{r}
PlotPredTrueBurn(pls_results, n = 1584)

ggsave('figures/fire_pls_predtrue_burn.pdf')
```
### Parameters
% correctly predicted parameters (density & directions):
```{r}
PlotPercCorrectParams(pls_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_pls_perc_correct.pdf')
```
RMSE, NRMSE, point prediction performance, and coverage for density parameter:
```{r}
PlotErrorsDensity(pls_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_pls_density_metrics.pdf')
```
F1, kappa score, and MCC for directions:
```{r}
PlotErrorsDirections(pls_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_pls_directions_metrics.pdf')
```
### Outcome variable
RMSE for burn percentage:
```{r}
PlotRMSEOut(pls_errors, n_plot = c(99, 792, 1584))

ggsave('figures/fire_pls_RMSE_burn.pdf')
```

## Model fit
