---
title: "WolfSheep_00_Run_Model"
author: "Femke Keij S2647168"
date: "2023-03-13"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Import Python modules:
```{python}
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import math
import statistics
import itertools
sns.set_style('white')
sns.set_context('talk')

import pyNetLogo # to run NetLogo from RStudio
```

Import R packages:
```{r}
# for importing / working with tidy data
library(tidyverse)
# for arranging plots
library(patchwork)
```

Set seed:
```{r}
set.seed(42)
```

# Running all possible parameter combinations
Link to and start the Fire model:
```{python}
netlogo = pyNetLogo.NetLogoLink(gui = True) # start netlogo

netlogo.load_model(r"C:\Users\Femke Keij\OneDrive\Thesis\R projects\LU thesis local\models\WolfSheep_myversion.nlogo")
# open model

# set to correct model version
netlogo.command('set model-version "sheep-wolves-grass"')
```

# Determine number of runs
Instead of combining a low, mid, and high value for each parameter, I use only the 25% and 75% quartile of each range. This brings the number of parameter combinations down from 2187 to 128.

```{python}
initial_number_sheep = [62, 188]
initial_number_wolves = [62, 188]
sheep_gain_from_food = [12, 38]
wolf_gain_from_food = [25, 72]
sheep_reproduce = [5, 15]
wolf_reproduce = [5, 15]
grass_regrowth = [25, 72]

dictionary = {'initial_number_sheep': [62, 188], 'initial_number_wolves': [62, 188], 'sheep_gain_from_food': [12, 38], 'wolf_gain_from_food': [25, 72], 'sheep_reproduce': [5, 15], 'wolf_reproduce': [5, 15], 'grass_regrowth': [25, 72]}

def expand_grid(data_dict):
    rows = itertools.product(*data_dict.values())
    return pd.DataFrame.from_records(rows, columns = data_dict.keys())

param_comb = expand_grid(dictionary)
```

1) Mean convergence
```{python}
# data frame to store results
means = pd.DataFrame(columns = ['initial_number_sheep', 'initial_number_wolves', 'sheep_gain_from_food', 'wolf_gain_from_food', 'sheep_reproduce', 'wolf_reproduce', 'grass_regrowth', 'run', 'mean_wolves', 'mean_sheep', 'mean_grass', 'wolves', 'sheep', 'grass'])
# add empty row to start
means = means.append({'initial_number_sheep': 0, 'initial_number_wolves': 0, 'sheep_gain_from_food': 0, 'wolf_gain_from_food': 0, 'sheep_reproduce': 0, 'wolf_reproduce': 0, 'grass_regrowth': 0, 'run': 0, 'mean_wolves': -100, 'mean_sheep': -100, 'mean_grass': -100, 'sheep': -100, 'wolves': -100, 'grass': -100}, ignore_index = True)

# set counter
count = 0
# set random seed
netlogo.command('clean')

for i in range(0,len(param_comb)):
  # set parameters
  initial_number_sheep = str(param_comb['initial_number_sheep'][i])
  initial_number_wolves = str(param_comb['initial_number_wolves'][i])
  sheep_gain_from_food = str(param_comb['sheep_gain_from_food'][i])
  wolf_gain_from_food = str(param_comb['wolf_gain_from_food'][i])
  sheep_reproduce = str(param_comb['sheep_reproduce'][i])
  wolf_reproduce = str(param_comb['wolf_reproduce'][i])
  grass_regrowth = str(param_comb['grass_regrowth'][i])
  netlogo.command(''.join(['set initial-number-sheep ', initial_number_sheep]))
  netlogo.command(''.join(['set initial-number-wolves ', initial_number_wolves]))
  netlogo.command(''.join(['set  sheep-gain-from-food ',  sheep_gain_from_food]))
  netlogo.command(''.join(['set wolf-gain-from-food ',  wolf_gain_from_food]))
  netlogo.command(''.join(['set sheep-reproduce ', sheep_reproduce]))
  netlogo.command(''.join(['set wolf-reproduce ', wolf_reproduce]))
  netlogo.command(''.join(['set grass-regrowth-time ', grass_regrowth]))
  
  # reset number of runs
  runs = 1
  # set up model
  netlogo.command('setup')
  # initial run
  netlogo.command('repeat 100 [go]')
  # record number of wolves, sheep, and grass
  sheep = netlogo.report('count sheep')
  wolves = netlogo.report('count wolves')
  grass = netlogo.report('count grass')
  # add to data frame
  means = means.append({'initial_number_sheep': initial_number_sheep, 'initial_number_wolves': initial_number_wolves, 'sheep_gain_from_food': sheep_gain_from_food, 'wolf_gain_from_food': wolf_gain_from_food, 'sheep_reproduce': sheep_reproduce, 'wolf_reproduce': wolf_reproduce, 'grass_regrowth': grass_regrowth, 'run': runs, 'mean_wolves': wolves, 'mean_sheep': sheep, 'mean_grass': grass, 'sheep': sheep, 'wolves': wolves, 'grass': grass}, ignore_index = True)
  # add count
  count = count + 1
  # repeat runs until mean wolves, sheep, and grass at 100 ticks
  # don't change anymore (up to threshold 0.1)
  while (abs(means['mean_sheep'][count - 1] - means['mean_sheep'][count]) > 0.1) & (abs(means['mean_wolves'][count - 1] - means['mean_wolves'][count]) > 0.1) & (abs(means['mean_grass'][count - 1] - means['mean_grass'][count]) > 0.1):
    # add to count
    count = count + 1
    # add to runs
    runs = runs + 1
    # set up model
    netlogo.command('setup')
    # run model
    netlogo.command('repeat 100 [go]')
    # record number of wolves, sheep, and grass
    sheep = netlogo.report('count sheep')
    wolves = netlogo.report('count wolves')
    grass = netlogo.report('count grass')
    # compute new means
    df = means[(means['initial_number_sheep'] == initial_number_sheep) & (means['initial_number_wolves'] == initial_number_wolves) & (means['sheep_gain_from_food'] == sheep_gain_from_food) & (means['wolf_gain_from_food'] == wolf_gain_from_food) & (means['sheep_reproduce'] == sheep_reproduce) & (means['wolf_reproduce'] == wolf_reproduce) & (means['grass_regrowth'] == grass_regrowth)]
    new_mean_sheep = ((df['mean_sheep'].mean() * len(df)) + sheep) / (len(df) + 1)
    new_mean_wolves = ((df['mean_wolves'].mean() * len(df)) + wolves) / (len(df) + 1)
    new_mean_grass = ((df['mean_grass'].mean() * len(df)) + grass) / (len(df) + 1)
    # add to dataframe
    means = means.append({'initial_number_sheep': initial_number_sheep, 'initial_number_wolves': initial_number_wolves, 'sheep_gain_from_food': sheep_gain_from_food, 'wolf_gain_from_food': wolf_gain_from_food, 'sheep_reproduce': sheep_reproduce, 'wolf_reproduce': wolf_reproduce, 'grass_regrowth': grass_regrowth, 'run': runs, 'mean_wolves': new_mean_wolves, 'mean_sheep': new_mean_wolves, 'mean_grass': new_mean_grass, 'sheep': sheep, 'wolves': wolves, 'grass': grass}, ignore_index = True)

means

means.to_csv('data/raw/wolfsheep_meancovergence.csv')
```

```{r}
means <- read_csv('data/raw/wolfsheep_meancovergence.csv')

runs_summarised <- means %>%
  group_by(initial_number_sheep, initial_number_wolves,
           sheep_gain_from_food, wolf_gain_from_food,
           sheep_reproduce, wolf_reproduce, grass_regrowth) %>%
  mutate(max_run = max(run)) %>%
  filter(run == max_run) %>%
  ungroup() %>%
  select('run')

runs_summarised %>%
  summarise(mean = mean(run),
            median = median(run),
            min = min(run),
            max = max(run))

as.data.frame(runs_summarised) %>%
  ggplot(mapping = aes(x = run)) +
  geom_histogram(binwidth = 2) +
  geom_vline(xintercept = 15) +
  geom_vline(xintercept = 7) +
  annotate(geom = 'text', label = 'median',
           x = 5, y = 11, angle = 90) +
  annotate(geom = 'text', label = 'mean',
           x = 13, y = 11, angle = 90) +
  theme_minimal() +
  labs(y = 'count',
       x = 'runs until mean convergence')
```
The mean number of required runs is 15, but the median is only 7. The highest number is 77.

2) Coefficient of variation
To determine how often the model should be run, I look at the coefficient of variation: $standard deviation / mean$. At the number of repetitions where this remains approximately the same, we can assume convergence [LU40]. This is only true for linear relationships, which we don't have here, but it will give an indication of how often to run the model. I only use a few parameter settings to cut down on the run time, and I also don't include the very extremes of the parameter settings since those tend to take longer to run.
```{python}
runs = [3, 5, 7, 10, 15, 20]
CVs = pd.DataFrame(columns = ['initial_number_sheep', 'initial_number_wolves', 'sheep_gain_from_food', 'wolf_gain_from_food', 'sheep_reproduce', 'wolf_reproduce', 'grass_regrowth', 'runs', 'CV_sheep', 'CV_wolves', 'CV_grass'])

# set random seed
netlogo.command('clean')

for i in range(0,len(param_comb)):
  # set parameters
  initial_number_sheep = str(param_comb['initial_number_sheep'][i])
  initial_number_wolves = str(param_comb['initial_number_wolves'][i])
  sheep_gain_from_food = str(param_comb['sheep_gain_from_food'][i])
  wolf_gain_from_food = str(param_comb['wolf_gain_from_food'][i])
  sheep_reproduce = str(param_comb['sheep_reproduce'][i])
  wolf_reproduce = str(param_comb['wolf_reproduce'][i])
  grass_regrowth = str(param_comb['grass_regrowth'][i])
  netlogo.command(''.join(['set initial-number-sheep ', initial_number_sheep]))
  netlogo.command(''.join(['set initial-number-wolves ', initial_number_wolves]))
  netlogo.command(''.join(['set  sheep-gain-from-food ',  sheep_gain_from_food]))
  netlogo.command(''.join(['set wolf-gain-from-food ',  wolf_gain_from_food]))
  netlogo.command(''.join(['set sheep-reproduce ', sheep_reproduce]))
  netlogo.command(''.join(['set wolf-reproduce ', wolf_reproduce]))
  netlogo.command(''.join(['set grass-regrowth-time ', grass_regrowth]))
  
  # set up data frame to store results
  out_df = pd.DataFrame(columns = ['sheep', 'wolves', 'grass'])
  for k in runs:
    for x in range(0, k):
      # setup
      netlogo.command('setup')
      # execute for 100 ticks
      netlogo.command('repeat 100 [go]')
      # record sheep, wolves, grass
      sheep = netlogo.report('count sheep')
      wolves = netlogo.report('count wolves')
      grass = netlogo.report ('count grass')
      # store
      out_df = out_df.append({'sheep': sheep, 'wolves': wolves, 'grass': grass}, ignore_index = True)
      
    # compute CV for sheep
    if out_df['sheep'].std() == 0: CV_new_sheep = 0
    # if std not zero
    if out_df['sheep'].std() != 0: CV_new_sheep = out_df['sheep'].mean() / out_df['sheep'].std()
    # compute CV for wolves
    if out_df['wolves'].std() == 0: CV_new_wolves = 0
    # if std not zero
    if out_df['wolves'].std() != 0: CV_new_wolves = out_df['wolves'].mean() / out_df['wolves'].std()
    # compute CV for grass
    if out_df['grass'].std() == 0: CV_new_grass = 0
    # if std not zero
    if out_df['grass'].std() != 0: CV_new_grass = out_df['grass'].mean() / out_df['grass'].std()

    # add
    CVs = CVs.append({'initial_number_sheep': initial_number_sheep, 'initial_number_wolves': initial_number_wolves, 'sheep_gain_from_food': sheep_gain_from_food, 'wolf_gain_from_food': wolf_gain_from_food, 'sheep_reproduce': sheep_reproduce, 'wolf_reproduce': wolf_reproduce, 'grass_regrowth': grass_regrowth, 'runs': k, 'CV_sheep': CV_new_sheep, 'CV_wolves': CV_new_wolves, 'CV_grass': CV_new_grass}, ignore_index = True)

CVs.to_csv('data/processed/wolfsheep_CVs_version2.csv')
```
Inspect results
```{r}
CVs <- read_csv('data/processed/wolfsheep_CVs_version2.csv')

CVs_grouped <- CVs %>%
  group_by(initial_number_sheep, initial_number_wolves,
           sheep_gain_from_food, wolf_gain_from_food,
           sheep_reproduce, wolf_reproduce,
           grass_regrowth) %>%
  mutate(number =  trunc(max(...1) / 5)) %>%
  ungroup()

p1 <- CVs_grouped %>%
  ggplot(mapping = aes(x = runs, y = CV_sheep,
                       colour = number, group = number)) +
  geom_point() +
  geom_line() +
  theme_minimal() +
  theme(legend.position = 'none') +
  labs(y = 'CV for number of sheep at tick 100')

p2 <- CVs_grouped %>%
  ggplot(mapping = aes(x = runs, y = CV_wolves,
                       colour = number, group = number)) +
  geom_point() +
  geom_line() +
  theme_minimal() +
  theme(legend.position = 'none') +
  labs(y = 'CV for number of wolves at tick 100')

p3 <- CVs_grouped %>%
  ggplot(mapping = aes(x = runs, y = CV_grass,
                       colour = number, group = number)) +
  geom_point() +
  geom_line() +
  theme_minimal() +
  theme(legend.position = 'none') +
  labs(y = 'CV for amount of grass at tick 100')

(p1 + p2) / (p3)
```
For the majority, the CV seems to level out around 10 or 15 runs.

I conclude that 10 runs is sufficient.

# Sensitivity analysis


# Sampling parameter space
I set up a Latin Hypercube sample of the parameter space to ensure adequate coverage. Then I run the model 15 times for each parameter combination.
```{r}
# for Latin hypercube sampling
library(lhs)

# n: number of samples to draw
# k: number of variables over which to sample
  
# LHS with n samples over k variables
A <- randomLHS(n = 40, k = 7)
  
# transform samples to represent the parameter space
# create empty matrix to hold parameter space samples
B <- matrix(nrow = nrow(A), ncol = ncol(A))
# round uniform distribution between 0 and 25 for
# initial number of sheep and wolves
B[,1] <- round(qunif(A[,1], min = 0, max = 250), digits = 0)
B[,2] <- round(qunif(A[,2], min = 0, max = 250), digits = 0)
# round uniform distribution between 0 and 50 for sheep gain from food
B[,3] <- round(qunif(A[,3], min = 0, max = 50), digits = 0)
# round uniform distribution between 0 and 100 for wolf gain from food
B[,4] <- round(qunif(A[,4], min = 0, max = 100), digits = 0)
# round uniform distribution between 1 and 20 for 
# sheep reproduction probability and wolf reproduction probability
B[,5] <- round(qunif(A[,5], min = 1, max = 20), digits = 0)
B[,6] <- round(qunif(A[,6], min = 1, max = 20), digits = 0)
# round uniform distribution between 0 and 100 for grass regrowth time
B[,7] <- round(qunif(A[,7], min = 0, max = 100), digits = 0)

# set column names
colnames(B) <- c('initial_number_sheep', 'initial_number_wolves',
                        'sheep_gain_from_food', 'wolf_gain_from_food',
                        'sheep_reproduce', 'wolf_reproduce',
                        'grass_regrowth')
```
Inspect sample to see if I'm happy with it:
```{r}
summary(B)
``` 
Save to import in Python:
```{r}
write_csv(as.data.frame(B), 'data/processed/wolfsheep_parameterspace.csv')
```

```{python}
all_comb = pd.read_csv('data/processed/wolfsheep_parameterspace.csv')

parameter_space_df = pd.DataFrame(columns = ['run', 'initial_number_sheep', 'initial_number_wolves', 'sheep_gain_from_food', 'wolf_gain_from_food', 'sheep_reproduce', 'wolf_reproduce', 'grass_regrowth', 'sheep', 'wolves', 'grass', 'ticks', 'combination_number'])

# set random seed
netlogo.command('clean')

# for each combination of parameters
for i in range(0, len(all_comb)):
  # retrieve parameters for run
  initial_number_sheep = str(all_comb['initial_number_sheep'][i])
  initial_number_wolves = str(all_comb['initial_number_wolves'][i])
  sheep_gain_from_food = str(all_comb['sheep_gain_from_food'][i])
  wolf_gain_from_food = str(all_comb['wolf_gain_from_food'][i])
  sheep_reproduce = str(all_comb['sheep_reproduce'][i])
  wolf_reproduce = str(all_comb['wolf_reproduce'][i])
  grass_regrowth = str(all_comb['grass_regrowth'][i])
  
  # set parameters
  netlogo.command(''.join(['set initial-number-sheep ', initial_number_sheep]))
  netlogo.command(''.join(['set initial-number-wolves ', initial_number_wolves]))
  netlogo.command(''.join(['set sheep-gain-from-food ', sheep_gain_from_food]))
  netlogo.command(''.join(['set wolf-gain-from-food ', wolf_gain_from_food]))
  netlogo.command(''.join(['set sheep-reproduce ', sheep_reproduce]))
  netlogo.command(''.join(['set wolf-reproduce ', wolf_reproduce]))
  netlogo.command(''.join(['set grass-regrowth-time ', grass_regrowth]))
  
  # run combination 15 times
  for j in range(1, 16):
    # set up
    netlogo.command('setup')
    # execute 1 tick at a time, and report
    for h in range(0, 500):
      netlogo.command('go')
      # record number of sheep, wolves, grass, and ticks
      sheep = netlogo.report('count sheep')
      wolves = netlogo.report('count wolves')
      grass = netlogo.report('count grass')
      ticks = netlogo.report('ticks')
      comb_number = i
      # add to data frame
      parameter_space_df = parameter_space_df.append({'run': j, 'initial_number_sheep': initial_number_sheep, 'initial_number_wolves': initial_number_wolves, 'sheep_gain_from_food': sheep_gain_from_food, 'wolf_gain_from_food': wolf_gain_from_food, 'sheep_reproduce': sheep_reproduce, 'wolf_reproduce': wolf_reproduce, 'grass_regrowth': grass_regrowth, 'sheep': sheep, 'wolves': wolves, 'grass': grass, 'ticks': ticks, 'combination_number': comb_number}, ignore_index = True)
      # break out of this level if the maximum number of sheep is reached and there are no wolves or grass left
      if wolves == 0 and grass == 0 and sheep > 30000:
        break
      
  print(''.join(['finished run ', str(i), '\n']), flush = True)

# save data as csv file
parameter_space_df.to_csv("C:/Users/Femke Keij/OneDrive/Thesis/R projects/LU thesis local/data/raw/wolfsheep_output.csv")
```

Close the model:
```{python}
netlogo.kill_workspace()
```

Stop running the python environment:
```{python}
quit
```

# Split into training and test data
Clear working directory:
```{r}
rm(list = ls(all = TRUE)) 
```

Import csv output format for the model as tidy data. We ignore the first column because it contains the indices.
```{r}
ws_output <- read_csv("data/raw/wolfsheep_output.csv",
                        col_names = TRUE)[, - 1]
```

Manipulate data so that there is 1 outcome for each parameter combination:
The outcomes for each parameter set are summarised by their mean sheep, wolves, and grass at every tick of the simulation, as well as the min and max of those numbers.
```{r}
all_comb <- read_csv('data/processed/wolfsheep_parameterspace.csv')

# group the data by parameter combination and ticks
ws_summary <- ws_output %>%
  group_by(combination_number, ticks) %>%
  # take the mean, min, and max wolf, sheep, and grass numbers over the 15 runs for each density
  summarise(mean_sheep = mean(sheep),
            min_sheep = min(sheep),
            max_sheep = max(sheep),
            mean_wolves = mean(wolves),
            min_wolves = min(wolves),
            max_wolves = max(wolves),
            mean_grass = mean(grass),
            min_grass = min(grass),
            max_grass = max(grass),
            .groups = 'keep')

# add the initial parameters back in
ws_summary$initial_number_sheep <- numeric(nrow(ws_summary))
ws_summary$initial_number_wolves <- numeric(nrow(ws_summary))
ws_summary$sheep_gain_from_food <- numeric(nrow(ws_summary))
ws_summary$wolves_gain_from_food <- numeric(nrow(ws_summary))
ws_summary$sheep_reproduce <- numeric(nrow(ws_summary))
ws_summary$wolves_reproduce <- numeric(nrow(ws_summary))
ws_summary$grass_regrowth <- numeric(nrow(ws_summary))

# change the combination numbers from 0 - 39 to 1 - 40
ws_summary$combination_number <- ws_summary$combination_number + 1

for(i in 1:nrow(ws_summary)){
  comb_numb <- ws_summary$combination_number[i]
  ws_summary$initial_number_sheep[i] <- as.numeric(all_comb[comb_numb, 1])
  ws_summary$initial_number_wolves[i] <- as.numeric(all_comb[comb_numb, 2])
  ws_summary$sheep_gain_from_food[i] <- as.numeric(all_comb[comb_numb, 3])
  ws_summary$wolves_gain_from_food[i] <- as.numeric(all_comb[comb_numb, 4])
  ws_summary$sheep_reproduce[i] <- as.numeric(all_comb[comb_numb, 5])
  ws_summary$wolves_reproduce[i] <- as.numeric(all_comb[comb_numb, 6])
  ws_summary$grass_regrowth[i] <- as.numeric(all_comb[comb_numb, 7])
}
  
ws_summary %>%
  write_csv(file = 'data/processed/wolfsheep_summary.csv')
```

Set up the training and test data:
I'm using a 80 - 20 split.
```{r}
set.seed(42)

ind <- sample(1:nrow(ws_output),
              size = nrow(ws_output) * 0.2,
              replace = FALSE)

ws_output %>%
  slice(ind) %>%
  write_csv(file = 'data/processed/wolfsheep_test.csv')

ws_output %>%
  slice(-ind) %>%
  write_csv(file = 'data/processed/wolfsheep_train.csv')
```