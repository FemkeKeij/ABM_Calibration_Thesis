---
title: "WolfSheep_01_Explore_Model"
author: "Femke Keij S2647168"
date: "2023-03-15"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear working directory:
```{r}
rm(list = ls(all = TRUE)) 
```

Packages used:
```{r}
# for importing / working with tidy data
library(tidyverse)

# for arranging ggplots
library(patchwork)

# for ggplot aesthetics
library(directlabels)
library(RColorBrewer)

# for k-means clustering
library(factoextra)

# for computing trends in data
library(trend)
```

Random seed:
```{r}
set.seed(42)
```

Read in the data:
```{r}
# complete data set
ws_output <- read_csv(
  'data/processed/wolfsheep_full.csv')

# output data summary
ws_summary <- read_csv(
  'data/processed/wolfsheep_summary.csv')
```

# Visualising parameter space
Plot distributions of outcomes.
Categorize the input parameters to make visualisation easier:
```{r}
ws_summary_cat <- ws_summary %>%
  mutate(sheep_cat = cut(initial_number_sheep,
                         breaks = c(-Inf, 50, 100, 150, 200, Inf),
                         labels = c('0 - 50', '51 - 100', '101 - 150',
                                    '151 - 200', '201 - 250')),
         wolves_cat = cut(initial_number_wolves,
                          breaks = c(-Inf, 50, 100, 150, 200, Inf),
                          labels = c('0 - 50', '51 - 100', '101 - 150',
                                    '151 - 200', '201 - 250')),
         sheep_food_cat = cut(sheep_gain_from_food,
                         breaks = c(-Inf, 25, Inf),
                         labels = c('0 - 25', '26 - 50')),
         wolves_food_cat = cut(wolves_gain_from_food,
                         breaks = c(-Inf, 25, 50, 75, Inf),
                         labels = c('0 - 25', '26 - 50', '51 - 75', '76 - 100')),
         sheep_rep_cat = cut(sheep_reproduce,
                         breaks = c(-Inf, 10, Inf),
                         labels = c('0 - 10', '11 - 20')),
         wolves_rep_cat = cut(wolves_reproduce,
                         breaks = c(-Inf, 10, Inf),
                         labels = c('1 - 10', '11 - 20')),
         grass_cat = cut(grass_regrowth,
                         breaks = c(-Inf, 25, 50, 75, Inf),
                         labels = c('0 - 25', '26 - 50', '51 - 75', '76 - 100')))
```

Ridgeline plot with the distributional outcomes of sheep, wolves, grass (3 plots), as related to the starting parameters
```{r}
PlotRidgelines <- function(parameter, timestep, label){
  p_sheep <- ws_summary_cat %>%
    filter(ticks == timestep) %>%
    ggplot(mapping = aes(x = mean_sheep,y = get(parameter))) +
    geom_density_ridges() +
    theme_minimal() +
      labs(x = c('distribution of number of sheep at timestep ',
                 timestep),
           y = label)
  
  p_wolves <- ws_summary_cat %>%
    filter(ticks == timestep) %>%
    ggplot(mapping = aes(x = mean_wolves,y = get(parameter))) +
    geom_density_ridges() +
    theme_minimal() +
      labs(x = c('distribution of number of wolves at timestep ',
                 timestep),
           y = label)
  
  p_grass <- ws_summary_cat %>%
    filter(ticks == timestep) %>%
    ggplot(mapping = aes(x = mean_grass,y = get(parameter))) +
    geom_density_ridges() +
    theme_minimal() +
      labs(x = c('distribution of number of grass at timestep ',
                 timestep),
           y = label)
  
  plot <- p_sheep / p_wolves / p_grass
}

p_100 <- PlotRidgelines(parameter = 'sheep_cat',
                        timestep = 100,
                        label = 'initial number of sheep')
p_250 <- PlotRidgelines(parameter = 'sheep_cat',
                        timestep = 250,
                        label = 'initial number of sheep')
p_500 <- PlotRidgelines(parameter = 'sheep_cat',
                        timestep = 500,
                        label = 'initial number of sheep')

p_100 + p_250 + p_500
```

# Identifying equifinality
Initial sheep and wolves plus the resulting final average numbers of sheep and wolves
```{r}
ws_summary_lasttick <- ws_summary %>%
  group_by(combination_number) %>%
  mutate(max_ticks = max(ticks)) %>%
  filter(ticks == max_ticks) %>%
  ungroup()

p1 <- ws_summary_lasttick %>%
  ggplot(mapping = aes(x = initial_number_sheep, y = initial_number_wolves)) +
  geom_point(mapping = aes(colour = mean_sheep),
             size = 5) +
  theme_minimal()+
  theme(panel.grid.minor = element_blank()) +
  labs(x = 'initial number of sheep',
       y = 'initial number of wolves',
       colour = 'mean number of \n sheep at last tick') +
  scale_colour_gradient(low = 'navy', high = 'red')

p2 <- ws_summary_lasttick %>%
  ggplot(mapping = aes(x = initial_number_sheep, y = initial_number_wolves)) +
  geom_point(mapping = aes(colour = mean_wolves),
             size = 5) +
  theme_minimal()+
  theme(panel.grid.minor = element_blank()) +
  labs(x = 'initial number of sheep',
       y = 'initial number of wolves',
       colour = 'mean number of \n wolves at last tick') +
  scale_colour_gradient(low = 'navy', high = 'red')

p1 + p2
```

Visualise all time series:
```{r}
p_sheep <- ws_summary %>%
  ggplot(mapping = aes(x = ticks, y = mean_sheep,
                       group = combination_number)) +
  geom_line(colour = 'bisque2') +
  theme_minimal() +
  labs(y = 'sheep')

p_wolves <- ws_summary %>%
  ggplot(mapping = aes(x = ticks, y = mean_wolves,
                       group = combination_number)) +
  geom_line(colour = 'darkgrey') +
  theme_minimal() +
  labs(y = 'wolves')

p_grass <- ws_summary %>%
  ggplot(mapping = aes(x = ticks, y = mean_grass,
                       group = combination_number)) +
  geom_line(colour = 'darkgreen') +
  theme_minimal() +
  labs(y = 'grass')

p_sheep + p_wolves + p_grass
```

Function for plots
```{r}
PlotParameterSpace <- function(parameter, label){
  p_sheep <- ws_summary_cat %>%
    ggplot(mapping = aes(x = ticks, y = log(mean_sheep),
                       group = combination_number,
                       colour = get(parameter))) +
    geom_line(alpha = 0.5) +
    theme_minimal() +
    labs(y = 'log sheep',
         colour = label) +
    scale_colour_brewer(palette = 'YlGn')

  p_wolves <- ws_summary_cat %>%
    ggplot(mapping = aes(x = ticks, y = log(mean_wolves),
                       group = combination_number,
                       colour = get(parameter))) +
    geom_line(alpha = 0.5) +
    theme_minimal() +
    labs(y = 'log wolves',
         colour = label) +
    scale_colour_brewer(palette = 'YlGn')

  p_grass <- ws_summary_cat %>%
    ggplot(mapping = aes(x = ticks, y = log(mean_grass),
                       group = combination_number,
                       colour = get(parameter))) +
    geom_line(alpha = 0.5) +
    theme_minimal() +
    labs(y = 'log grass',
         colour = label) +
    scale_colour_brewer(palette = 'YlGn')
  
  plot <- p_sheep + p_wolves + p_grass + plot_layout(guides = 'collect')
  
  return(plot)
}
```

1) initial_number_sheep
```{r}
PlotParameterSpace(parameter = 'sheep_cat',
                   label = 'initial number of sheep')
```

2) initial_number_wolves
```{r}
PlotParameterSpace(parameter = 'wolves_cat',
                   label = 'initial numbr of wolves')
```

3) sheep_gain_from_food
```{r}
PlotParameterSpace(parameter = 'sheep_food_cat',
                   label = 'sheep gain from food')
```

4) wolves_gain_from_food
```{r}
PlotParameterSpace(parameter = 'wolves_food_cat',
                   label = 'wolves gain from food')
```

5) sheep_reproduce
```{r}
PlotParameterSpace(parameter = 'sheep_rep_cat',
                   label = 'probability sheep reproduce')
```

6) wolves_reproduce
```{r}
PlotParameterSpace(parameter = 'wolves_rep_cat',
                   label = 'probability wolves reproduce')
```

7) grass_regrowth_time
```{r}
PlotParameterSpace(parameter = 'grass_cat',
                   label = 'grass regrowth time')
```
It seems very difficult to say anything about equifinality here, since there are so many different parameters to look at at once.

Apply a k-means clustering to the sheep, grass, and wolf values at timesteps 100, 250, and 500. Then take at which parameter combinations end up in the same cluster.
Start by formatting the data for the analysis
```{r}
# retrieve sheep, grass, and wolves at timesteps 100, 250, and 500 for every parameter combination
kmeans_data <- ws_summary %>%
  filter(ticks %in% c(1, 100, 250, 500)) %>%
  pivot_wider(names_from = ticks,
              values_from = c(mean_sheep, mean_wolves, mean_grass)) %>%
  # the NAs can all be replaced by 0, they result from the simulation
  # stopping early if there are no agents left
  replace(is.na(.), 0) %>%
  select(mean_sheep_100, mean_sheep_250, mean_sheep_500,
         mean_wolves_100, mean_wolves_250, mean_wolves_500,
         mean_grass_100, mean_grass_250, mean_grass_500)

# standardize data
kmeans_data <- scale(kmeans_data)
```

Determine optimal number of clusters:
- elbow method: we want to minimize the total within-cluster variation (or within-cluster sum of squares). we compute the wss for a number of different clusters, and then choose the number of clusters where we see the 'elbow' occur
- average silhouette method: this approach inspects how well each observation fits within its cluster. If the average is high, that indicates good clustering.
```{r}
# elbow method
fviz_nbclust(kmeans_data, kmeans, method = "wss")

# silhouette method
fviz_nbclust(kmeans_data, kmeans, method = "silhouette")
```

I'll be using 5 centers:
```{r}
clustering <- kmeans(kmeans_data, centers = 5, nstart = 25)

fviz_cluster(clustering, data = kmeans_data)
```

Now I can inspect which parameter combinations ended up in the same cluster.
```{r}
clustered_parameters <- ws_summary %>%
  select(combination_number,
         initial_number_sheep, initial_number_wolves,
         wolves_gain_from_food, wolves_reproduce,
         sheep_gain_from_food, sheep_reproduce,
         grass_regrowth) %>%
  distinct() %>%
  add_column(cluster = clustering$cluster)

# visualise results
PlotClusters <- function(data, parameters, labels){
  for(i in length(parameters)){
    plot <- data %>%
      ggplot(mapping = aes(x = as.factor(cluster),
                         y = get(parameters[i]),
                         colour = as.factor(cluster),
                         fill = as.factor(cluster))) +
      geom_jitter(width = 0.2) +
      geom_boxplot(alpha = 0.1, width = 0.4,
                 outlier.colour = 'transparent') +
      theme_minimal() +
      labs(x = 'clusters',
         y = label[i]) +
      theme(legend.position = 'none')
    
    assign(paste("plot", get(parameters[i]), sep="_"),
           plot)
  }
  
  all_plots <- (plot_initial_number_sheep +
                  plot_initial_number_wolves +
                  plot_sheep_gain_from_food +
                  plot_wolves_gain_from_food) / (
                    plot_sheep_reproduce +
                      plot_wolves_reproduce +
                      plot_grass_regrowth)
  
  return(all_plots)
}

kmeans_plots <- PlotClusters(clustered_parameters,
                             c('initial_number_sheep',
                               'initial_number_wolves',
                               'sheep_gain_from_food',
                               'wolves_gain_from_food',
                               'sheep_reproduce',
                               'wolves_reproduce',
                               'grass_regrowth'),
                             c('initial number of sheep',
                               'initial number of wolves',
                               'sheep gain from food',
                               'wolves gain from food',
                               'probability sheep reproduce',
                               'probability wolves reproduce',
                               'grass regrowth time'))
```
Looking at this it seems like the initial parameter can tell us very little about what the outcome will be like. So a lot of equifinality.

Hierarchical dynamic time warping clustering
```{r}
# create data with all time points, standardize
hierarchical_data <- ws_summary %>%
  select(combination_number,
         mean_sheep, mean_wolves, mean_grass, ticks) %>%
  pivot_wider(names_from = ticks,
              values_from = c(mean_sheep, mean_wolves, mean_grass)) %>%
  select(- combination_number) %>%
  scale()

# change to list format to allow for different lengths of time series
#   as input for the hierarchical clustering DTW algorithm
hierarchical_data_list <- list()

for(i in 1:nrow(hierarchical_data)){
  # keep only ticks with values
  throw <- which(is.na(hierarchical_data[i, ]))
  keep <- hierarchical_data[i, - throw]
  hierarchical_data_list <- append(hierarchical_data_list, keep)
}

# train hierarchical clustering with DTW
hierarchical_clust <- tsclust(hierarchical_data_list,
                              type = 'h',
                              k = 5L,
                              distance = 'dtw')

# plot results
plot(hierarchical_clust, type = 'sc')

# plot rest of results (haven't tried running this yet)
hierarchical_clustered_parameters <- ws_summary %>%
  select(- c(mean_sheep, mean_wolves, mean_grass, ticks)) %>%
  distinct() %>%
  mutate(cluter = cutree(hierarchical_clust, k = 6L))
  
hierarchical_plots <- PlotClusters(hierarchical_clustered_parameters,
                             c('initial_number_sheep',
                               'initial_number_wolves',
                               'sheep_gain_from_food',
                               'wolves_gain_from_food',
                               'sheep_reproduce',
                               'wolves_reproduce',
                               'grass_regrowth'),
                             c('initial number of sheep',
                               'initial number of wolves',
                               'sheep gain from food',
                               'wolves gain from food',
                               'probability sheep reproduce',
                               'probability wolves reproduce',
                               'grass regrowth time'))
```

# Identifying unidentifiable parameters
Correlation between parameters and outputs:
```{r}
PlotCorrelations <- function(parameter){
  p_sheep <- ws_summary %>%
    filter(ticks %in% c(50, 100, 250, 500)) %>%
    ggplot(mapping = aes(x = get(parameter), y = log(mean_sheep))) +
    geom_point() +
    geom_smooth(method = 'lm', se = FALSE) +
    theme_minimal() +
    labs(x = parameter, y = 'sheep') +
    facet_grid(~ as.factor(ticks))
  
  p_wolves <- ws_summary %>%
    filter(ticks %in% c(50, 100, 250, 500)) %>%
    ggplot(mapping = aes(x = get(parameter), y = log(mean_wolves))) +
    geom_point() +
    geom_smooth(method = 'lm', se = FALSE) +
    theme_minimal() +
    labs(x = parameter, y = 'wolves') +
    facet_grid(~ as.factor(ticks))
  
  p_grass <- ws_summary %>%
    filter(ticks %in% c(50, 100, 250, 500)) %>%
    ggplot(mapping = aes(x = get(parameter), y = mean_grass)) +
    geom_point() +
    geom_smooth(method = 'lm', se = FALSE) +
    theme_minimal() +
    labs(x = parameter, y = 'grass') +
    facet_grid(~ as.factor(ticks))
  
  plot <- p_sheep / p_wolves / p_grass + plot_layout(guides = 'collect')
  
  return(plot)
}
```

1) initial_number_sheep
```{r}
PlotCorrelations('initial_number_sheep')
```

2) initial_number_wolves
```{r}
PlotCorrelations('initial_number_wolves')
```

3) sheep_gain_from_food
```{r}
PlotCorrelations('sheep_gain_from_food')
```

4) wolves_gain_from_food
```{r}
PlotCorrelations('wolves_gain_from_food')
```

5) sheep_reproduce
```{r}
PlotCorrelations('sheep_reproduce')
```

6) wolves_reproduce
```{r}
PlotCorrelations('wolves_reproduce')
```

7) grass_regrowth_time
```{r}
PlotCorrelations('grass_regrowth')
```

It looks like all parameters are at least influential on one of the outputs, so they appear identifiable in that sense.

However, we can also see that a lot of the relationships look the same, indicating that the parameters may be unidentifiable because they influence the output parameters in the same way.

# Temporal autcorrelation plots
Compute (partial) autocorrelation for each time series
```{r}
# dataframe to store results
autocorrelation_df <- tibble(combination_number = numeric(),
                              lag = numeric(),
                              acf_sheep = numeric(),
                              pacf_sheep = numeric(),
                              acf_wolves = numeric(),
                              pacf_wolves = numeric(),
                              acf_grass = numeric(),
                              pacf_grass = numeric())

# per time series (parameter set)
for(i in unique(ws_summary$combination_number)){
  select <- ws_summary %>%
    filter(combination_number == i)
  
  # compute acf and pacf
  acfs_sheep <- acf(select$mean_sheep, plot = FALSE,
                    lag.max = 45, type = 'correlation')$acf
  pacfs_sheep <- pacf(select$mean_sheep, plot = FALSE,
                      lag.max = 45)$acf
  acfs_wolves <- acf(select$mean_wolves, plot = FALSE,
                     lag.max = 45, type = 'correlation')$acf
  pacfs_wolves <- pacf(select$mean_wolves, plot = FALSE,
                       lag.max = 45)$acf
  acfs_grass <- acf(select$mean_grass, plot = FALSE,
                    lag.max = 45, type = 'correlation')$acf
  pacfs_grass <- pacf(select$mean_grass, plot = FALSE,
                     lag.max = 45)$acf
  
  # add 0 in front of the pacf series, since they start at lag 1, not 0
  add_df <- tibble(combination_number = rep(i, 46),
                   lag = 0:45,
                   acf_sheep = acfs_sheep,
                   pacf_sheep = c(0, pacfs_sheep),
                   acf_wolves = acfs_wolves,
                   pacf_wolves = c(0, pacfs_wolves),
                   acf_grass = acfs_grass,
                   pacf_grass = c(0, pacfs_grass))
  
  autocorrelation_df <- autocorrelation_df %>%
    add_row(add_df)
}
```
Plot (partial) autocorrelations:
```{r}
acf_sheep <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = acf_sheep,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'autocorrelation sheep') +
  theme_minimal() +
  theme(legend.position = 'none')

pacf_sheep <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = pacf_sheep,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'partial autocorrelation sheep') +
  theme_minimal() +
  theme(legend.position = 'none')

acf_wolves <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = acf_wolves,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'autocorrelation wolves') +
  theme_minimal() +
  theme(legend.position = 'none')

pacf_wolves <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = pacf_wolves,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'partial autocorrelation wolves') +
  theme_minimal() +
  theme(legend.position = 'none')

acf_grass <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = acf_grass,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'autocorrelation grass') +
  theme_minimal() +
  theme(legend.position = 'none')

pacf_grass <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = pacf_grass,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'partial autocorrelation grass') +
  theme_minimal() +
  theme(legend.position = 'none')

autocorrelation_plot <- (acf_sheep + acf_wolves + acf_grass) / (pacf_sheep + pacf_wolves + pacf_grass)

ggsave(autocorrelation_plot,
       filename = 'figures/wolfsheep_autocorrelation.pdf')
```

# Sensitivity analysis