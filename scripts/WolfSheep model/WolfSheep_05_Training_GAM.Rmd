---
title: "WolfSheep_05_Training_GAM"
author: "Femke Keij S2647168"
date: "2023-07-12"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Preliminaries
Clear working directory & set random seed:
```{r}
rm(list = ls(all = TRUE))

set.seed(42)
```

Packages used:
```{r}
# for importing / working with tidy data
library(tidyverse)

# for ggplot
library(directlabels)
library(patchwork)
library(ggbeeswarm)

# for creating the cross-validation folds
library(caret)
```

Read in the data:
```{r}
# training data
ws_train <- read_csv('data/processed/wolfsheep_timesteps_training.csv')
```

# Fitting with cross-validation
We fit a separate generalized additive model for each input parameter. All output variables serve as predictors. We apply a 5-fold cross-validation, and obtain the error computations for each one. The errors are then averaged across the 5 folds.

Function to compute errors for continuous parameters:
```{r}
ComputeErrorsContinuous <- function(predicted, true,
                                    mean_training, variable,
                                    fold){
  # predicted: predicted values
  # true: true values
  # mean_training: mean of values in training data set
  
  N <- length(true)
  
  perc_correct <- sum(predicted == true) / N
  perc_correct_cat <- sum(predicted >= true - 0.1 * true &
                            predicted <= true + 0.1 * true)
  RMSE <- sqrt(sum((predicted - true)^2)) / N
  NRMSE <- (sqrt(sum((predicted - true)^2)) / N) / sd(true)
  point_pred <- 1 - sum(sqrt((predicted - true)^2)) /
                    sum(sqrt((true - mean_training)^2))
  
  return(tibble(fold = fold,
                variable = variable,
                perc_correct = perc_correct,
                perc_correct_cat = perc_correct_cat,
                RMSE = RMSE,
                NRMSE = NRMSE,
                point_pred = point_pred))
}
```

Function to cross-validate generalized additive model
##### CONTINUE HERE #######

```{r}
WolfSheepSimpleRegression <- function(data,
                                      sampling_method,
                                      timesteps,
                                      noise){
  # create the folds
  flds <- createFolds(1:nrow(data),
                      k = 5, list = TRUE, returnTrain = FALSE)

  # to store the results
  results_df <- tibble(fold = numeric(),
                       variable = character(),
                       perc_correct = numeric(),
                       perc_correct_cat = numeric(),
                       RMSE = numeric(),
                       NRMSE = numeric(),
                       point_pred = numeric())

  # for each cross-validation fold
  for(i in 1:5){
    # remove the test fold to create the training data
    dat <- ws_train %>%
      filter(!combination_number %in% unlist(flds[i])) %>%
      select(- combination_number)
  
    # obtain the test fold
    dat_test <- ws_train %>%
      filter(combination_number %in% unlist(flds[i])) %>%
      select(- combination_number)
  
    # train the linear regressions
    initial_sheep <- lm(formula = initial_number_sheep ~ .,
                      data = dat)
    initial_wolves <- lm(formula = initial_number_wolves ~ .,
                       data = dat)
    food_sheep <- lm(formula = sheep_gain_from_food ~ .,
                     data = dat)
    food_wolves <- lm(formula = wolves_gain_from_food ~ .,
                    data = dat)
    rep_sheep <- lm(formula = sheep_reproduce ~ .,
                  data = dat)
    rep_wolves <- lm(formula = wolves_reproduce ~ .,
                   data = dat)
    grass <- lm(formula = grass_regrowth ~ .,
              data = dat)
  
    # predict the left-out fold
    pred_initial_sheep <- predict(initial_sheep, data = dat_test)
    pred_initial_wolves <- predict(initial_wolves, data = dat_test)
    pred_food_sheep <- predict(food_sheep, data = dat_test)
    pred_food_wolves <- predict(food_wolves, data = dat_test)
    pred_rep_sheep <- predict(rep_sheep, data = dat_test)
    pred_rep_wolves <- predict(rep_sheep, data = dat_test)
    pred_grass <- predict(grass, data = dat_test)
    
    # compute mean input parameters in training data for
    # point prediction computation
    mean_initial_sheep <- mean(dat$initial_number_sheep)
    mean_initial_wolves <- mean(dat$initial_number_wolves)
    mean_food_sheep <- mean(dat$sheep_gain_from_food)
    mean_food_wolves <- mean(dat$wolves_gain_from_food)
    mean_rep_sheep <- mean(dat$sheep_reproduce)
    mean_rep_wolves <- mean(dat$wolves_reproduce)
    mean_grass <- mean(dat$grass_regrowth)
  
    # add error computations
    results_df <- results_df %>%
      add_row(ComputeErrorsContinuous(pred_initial_sheep,
                                      dat_test$initial_number_sheep,
                                      mean_initial_sheep,
                                      variable = 'initial number of sheep',
                                      fold = i)) %>%
      add_row(ComputeErrorsContinuous(pred_initial_wolves,
                                      dat_test$initial_number_wolves,
                                      mean_initial_sheep,
                                      variable = 'initial number of wolves',
                                      fold = i)) %>%
      add_row(ComputeErrorsContinuous(pred_food_sheep,
                                      dat_test$sheep_gain_from_food,
                                      mean_food_sheep,
                                      variable = 'sheep gain from food',
                                      fold = i)) %>%
      add_row(ComputeErrorsContinuous(pred_food_wolves,
                                      dat_test$wolves_gain_from_food,
                                      mean_food_wolves,
                                      variable = 'wolves gain from food',
                                      fold = i)) %>%
      add_row(ComputeErrorsContinuous(pred_rep_sheep,
                                      dat_test$sheep_reproduce,
                                      mean_rep_sheep,
                                      variable = 'probability sheep reproduce',
                                      fold = i)) %>%
      add_row(ComputeErrorsContinuous(pred_rep_wolves,
                                      dat_test$wolves_reproduce,
                                      mean_rep_wolves,
                                      variable = 'probability wolves reproduce',
                                      fold = i)) %>%
      add_row(ComputeErrorsContinuous(pred_grass,
                                      dat_test$grass_regrowth,
                                      mean_grass,
                                      variable = 'grass regrowth time',
                                      fold = i))
  }
  
  # compute mean of each statistic over the 5 folds
  results_df <- results_df %>%
    group_by(variable)%>%
    summarise_all(mean) %>%
    select(- fold) %>%
    add_column(sampling_method = sampling_method,
               timesteps = timesteps,
               noise = noise)
  
  return(results_df)
}
```

For now:
```{r}
out <- WolfSheepSimpleRegression(ws_train,
                                 sampling_method = 'random',
                                 timesteps = 'all',
                                 noise = 'no')
```

1) no noise, 10 steps, random sampling

2) no noise, 20 steps, random sampling

3) no noise, 50 steps, random sampling

4) no noise, endpoint, random sampling

4) no noise, 10 steps, lhs

5) no noise, 20 steps, lhs

6) no noise, 50 steps, lhs

7) no noise, endpoing, 

1) no noise, 10 steps, random sampling

2) no noise, 20 steps, random sampling

3) no noise, 50 steps, random sampling

4) no noise, 10 steps, lhs

5) no noise, 20 steps, lhs

6) no noise, 50 steps, random sampling

# Visualise results
Compare each error metric:
```{r}
out_long <- out %>%
  pivot_longer(cols = c(perc_correct_cat,
                        perc_correct,
                        RMSE, NRMSE, point_pred),
               names_to = 'metric',
               values_to = 'vals')

# no noise
out_long %>%
  filter(noise == 'no') %>%
  ggplot(mapping = aes(x = timesteps,
                       y = vals,
                       fill = sampling_method)) +
  geom_bar(position = 'dodge', stat = 'identity') +
  facet_wrap(~ metric + variable,
             scales = 'free_y')

# with noise
out_long %>%
  filter(noise == 'yes') %>%
  ggplot(mapping = aes(x = timesteps,
                       y = vals,
                       fill = sampling_method)) +
  geom_bar(position = 'dodge', stat = 'identity') +
  facet_grid(~ metric + variable,
             scales = 'free_y')
```