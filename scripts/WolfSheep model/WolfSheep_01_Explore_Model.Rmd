---
title: "WolfSheep_01_Explore_Model"
author: "Femke Keij S2647168"
date: "2023-03-15"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear working directory:
```{r}
rm(list = ls(all = TRUE)) 
```

Packages used:
```{r}
# for importing / working with tidy data
library(tidyverse)

# for arranging ggplots
library(patchwork)

# for ggplot aesthetics
library(directlabels)
library(RColorBrewer)

# for computing trends in data
library(trend)
```

Random seed:
```{r}
set.seed(42)
```

Read in the data:
```{r}
# complete data set
ws_output <- read_csv(
  'data/raw/wolfsheep_output.csv')

# output data summary
ws_summary <- read_csv(
  'data/processed/wolfsheep_summary.csv')
```

# ABM inspection: visualise parameter space
Plot distributions of outcomes.
Categorize the input parameters to make visualisation easier:
```{r}
ws_summary_cat <- ws_summary %>%
  mutate(sheep_cat = cut(initial_number_sheep,
                         breaks = c(-Inf, 50, 100, 150, 200, Inf),
                         labels = c('0 - 50', '51 - 100', '101 - 150',
                                    '151 - 200', '201 - 250')),
         wolves_cat = cut(initial_number_wolves,
                          breaks = c(-Inf, 50, 100, 150, 200, Inf),
                          labels = c('0 - 50', '51 - 100', '101 - 150',
                                    '151 - 200', '201 - 250')),
         sheep_food_cat = cut(sheep_gain_from_food,
                         breaks = c(-Inf, 25, Inf),
                         labels = c('0 - 25', '26 - 50')),
         wolves_food_cat = cut(wolves_gain_from_food,
                         breaks = c(-Inf, 25, 50, 75, Inf),
                         labels = c('0 - 25', '26 - 50', '51 - 75', '76 - 100')),
         sheep_rep_cat = cut(sheep_reproduce,
                         breaks = c(-Inf, 10, Inf),
                         labels = c('0 - 10', '11 - 20')),
         wolves_rep_cat = cut(wolves_reproduce,
                         breaks = c(-Inf, 10, Inf),
                         labels = c('1 - 10', '11 - 20')),
         grass_cat = cut(grass_regrowth,
                         breaks = c(-Inf, 25, 50, 75, Inf),
                         labels = c('0 - 25', '26 - 50', '51 - 75', '76 - 100')))
```

Ridgeline plot with the distributional outcomes of sheep, wolves, grass (3 plots), as related to the starting parameters
```{r}
PlotRidgelines <- function(parameter, timestep, label){
  p_sheep <- ws_summary_cat %>%
    filter(ticks == timestep) %>%
    ggplot(mapping = aes(x = mean_sheep,y = get(parameter))) +
    geom_density_ridges() +
    theme_minimal() +
      labs(x = c('distribution of number of sheep at timestep ',
                 timestep),
           y = label)
  
  p_wolves <- ws_summary_cat %>%
    filter(ticks == timestep) %>%
    ggplot(mapping = aes(x = mean_wolves,y = get(parameter))) +
    geom_density_ridges() +
    theme_minimal() +
      labs(x = c('distribution of number of wolves at timestep ',
                 timestep),
           y = label)
  
  p_grass <- ws_summary_cat %>%
    filter(ticks == timestep) %>%
    ggplot(mapping = aes(x = mean_grass,y = get(parameter))) +
    geom_density_ridges() +
    theme_minimal() +
      labs(x = c('distribution of number of grass at timestep ',
                 timestep),
           y = label)
  
  plot <- p_sheep / p_wolves / p_grass
}

p_100 <- PlotRidgelines(parameter = 'sheep_cat',
                        timestep = 100,
                        label = 'initial number of sheep')
p_250 <- PlotRidgelines(parameter = 'sheep_cat',
                        timestep = 250,
                        label = 'initial number of sheep')
p_500 <- PlotRidgelines(parameter = 'sheep_cat',
                        timestep = 500,
                        label = 'initial number of sheep')

p_100 + p_250 + p_500
```

# ABM inspection: looking for equifinality
Initial sheep and wolves plus the resulting final average numbers of sheep and wolves
```{r}
ws_summary_lasttick <- ws_summary %>%
  group_by(combination_number) %>%
  mutate(max_ticks = max(ticks)) %>%
  filter(ticks == max_ticks) %>%
  ungroup()

p1 <- ws_summary_lasttick %>%
  ggplot(mapping = aes(x = initial_number_sheep, y = initial_number_wolves)) +
  geom_point(mapping = aes(colour = mean_sheep),
             size = 5) +
  theme_minimal()+
  theme(panel.grid.minor = element_blank()) +
  labs(x = 'initial number of sheep',
       y = 'initial number of wolves',
       colour = 'mean number of \n sheep at last tick') +
  scale_colour_gradient(low = 'navy', high = 'red')

p2 <- ws_summary_lasttick %>%
  ggplot(mapping = aes(x = initial_number_sheep, y = initial_number_wolves)) +
  geom_point(mapping = aes(colour = mean_wolves),
             size = 5) +
  theme_minimal()+
  theme(panel.grid.minor = element_blank()) +
  labs(x = 'initial number of sheep',
       y = 'initial number of wolves',
       colour = 'mean number of \n wolves at last tick') +
  scale_colour_gradient(low = 'navy', high = 'red')

p1 + p2
```

Visualise all time series:
```{r}
p_sheep <- ws_summary %>%
  ggplot(mapping = aes(x = ticks, y = mean_sheep,
                       group = combination_number)) +
  geom_line(colour = 'bisque2') +
  theme_minimal() +
  labs(y = 'sheep')

p_wolves <- ws_summary %>%
  ggplot(mapping = aes(x = ticks, y = mean_wolves,
                       group = combination_number)) +
  geom_line(colour = 'darkgrey') +
  theme_minimal() +
  labs(y = 'wolves')

p_grass <- ws_summary %>%
  ggplot(mapping = aes(x = ticks, y = mean_grass,
                       group = combination_number)) +
  geom_line(colour = 'darkgreen') +
  theme_minimal() +
  labs(y = 'grass')

p_sheep + p_wolves + p_grass
```

Function for plots
```{r}
PlotParameterSpace <- function(parameter, label){
  p_sheep <- ws_summary_cat %>%
    ggplot(mapping = aes(x = ticks, y = mean_sheep,
                       group = combination_number,
                       colour = get(parameter))) +
    geom_line() +
    theme_minimal() +
    labs(y = 'sheep',
         colour = label)

  p_wolves <- ws_summary_cat %>%
    ggplot(mapping = aes(x = ticks, y = mean_wolves,
                       group = combination_number,
                       colour = get(parameter))) +
    geom_line() +
    theme_minimal() +
    labs(y = 'wolves',
         colour = label)

  p_grass <- ws_summary_cat %>%
    ggplot(mapping = aes(x = ticks, y = mean_grass,
                       group = combination_number,
                       colour = get(parameter))) +
    geom_line() +
    theme_minimal() +
    labs(y = 'grass',
         colour = label)
  
  plot <- p_sheep + p_wolves + p_grass + plot_layout(guides = 'collect')
  
  return(plot)
}
```

1) initial_number_sheep
```{r}
PlotParameterSpace(parameter = 'sheep_cat',
                   label = 'initial number of sheep')
```

2) initial_number_wolves
```{r}
PlotParameterSpace(parameter = 'wolves_cat',
                   label = 'initial numbr of wolves')
```

3) sheep_gain_from_food
```{r}
PlotParameterSpace(parameter = 'sheep_food_cat',
                   label = 'sheep gain from food')
```

4) wolves_gain_from_food
```{r}
PlotParameterSpace(parameter = 'wolves_food_cat',
                   label = 'wolves gain from food')
```

5) sheep_reproduce
```{r}
PlotParameterSpace(parameter = 'sheep_rep_cat',
                   label = 'probability sheep reproduce')
```

6) wolves_reproduce
```{r}
PlotParameterSpace(parameter = 'wolves_rep_cat',
                   label = 'probability wolves reproduce')
```

7) grass_regrowth_time
```{r}
PlotParameterSpace(parameter = 'grass_cat',
                   label = 'grass regrowth time')
```
It seems very difficult to say anything about equifinality here, since there are so many different parameters to look at at once.

Apply a k-means clustering to the sheep, grass, and wolf values at timesteps 100, 250, and 500. Then take at which parameter combinations end up in the same cluster.
Start by formatting the data for the analysis
```{r}
# retrieve sheep, grass, and wolves at timesteps 100, 250, and 500 for every parameter combination
kmeans_data <- ws_summary %>%
  filter(ticks %in% c(1, 100, 250, 500)) %>%
  pivot_wider(names_from = ticks,
              values_from = c(mean_sheep, mean_wolves, mean_grass)) %>%
  # the NAs can all be replaced by 0, they result from the simulation
  # stopping early if there are no agents left
  replace(is.na(.), 0) %>%
  select(mean_sheep_100, mean_sheep_250, mean_sheep_500,
         mean_wolves_100, mean_wolves_250, mean_wolves_500,
         mean_grass_100, mean_grass_250, mean_grass_500)

# standardize data
kmeans_data <- scale(kmeans_data)
```

Determine optimal number of clusters:
- elbow method: we want to minimize the total within-cluster variation (or within-cluster sum of squares). we compute the wss for a number of different clusters, and then choose the number of clusters where we see the 'elbow' occur
- average silhouette method: this approach inspects how well each observation fits within its cluster. If the average is high, that indicates good clustering.
```{r}
# for k-means clustering
library(factoextra)

# elbow method
fviz_nbclust(kmeans_data, kmeans, method = "wss")

# silhouette method
fviz_nbclust(kmeans_data, kmeans, method = "silhouette")
```

I'll be using 5 centers:
```{r}
clustering <- kmeans(kmeans_data, centers = 5, nstart = 25)

fviz_cluster(clustering, data = kmeans_data)
```

Now I can inspect which parameter combinations ended up in the same cluster.
```{r}
clustered_parameters <- ws_summary %>%
  select(combination_number,
         initial_number_sheep, initial_number_wolves,
         wolves_gain_from_food, wolves_reproduce,
         sheep_gain_from_food, sheep_reproduce,
         grass_regrowth) %>%
  distinct() %>%
  add_column(cluster = clustering$cluster)

# visualise results
PlotClusters <- function(parameter, label){
  plot <- clustered_parameters %>%
    ggplot(mapping = aes(x = as.factor(cluster),
                       y = get(parameter),
                       colour = as.factor(cluster),
                       fill = as.factor(cluster))) +
    geom_jitter(width = 0.2) +
    geom_boxplot(alpha = 0.1, width = 0.4,
               outlier.colour = 'transparent') +
    theme_minimal() +
    labs(x = '5-means clusters',
       y = label) +
    theme(legend.position = 'none')
  
  return(plot)
}

clusters_sheep <- PlotClusters('initial_number_sheep',
                               label = 'initial number of sheep')
clusters_wolves <- PlotClusters('initial_number_wolves',
                                label = 'initial number of wolves')
clusters_food_sheep <- PlotClusters('sheep_gain_from_food',
                                    label = 'sheep gain from food')
clusters_food_wolves <- PlotClusters('wolves_gain_from_food',
                                     label = 'wolves gain from food')
clusters_rep_sheep <- PlotClusters('sheep_reproduce',
                                   label = 'probability sheep reproduce')
clusters_rep_wolves <- PlotClusters('wolves_reproduce',
                                    label = 'probability wolves reproduce')
clusters_grass <- PlotClusters('grass_regrowth',
                               label = 'grass regrowth time')

(clusters_sheep + clusters_wolves + clusters_food_sheep + clusters_food_wolves) / (clusters_rep_sheep + clusters_rep_wolves + clusters_grass)
```
Looking at this it seems like the initial parameter can tell us very little about what the outcome will be like. So a lot of equifinality.


# ABM inspection: Identifying unidentifiable parameters
Correlation between parameters and outputs:
```{r}
PlotCorrelations <- function(parameter){
  p_sheep <- ws_summary %>%
    filter(ticks %in% c(50, 100, 250, 500)) %>%
    ggplot(mapping = aes(x = get(parameter), y = mean_sheep)) +
    geom_point() +
    geom_smooth(method = 'lm', se = FALSE) +
    theme_minimal() +
    labs(x = parameter, y = 'sheep') +
    facet_grid(~ as.factor(ticks))
  
  p_wolves <- ws_summary %>%
    filter(ticks %in% c(50, 100, 250, 500)) %>%
    ggplot(mapping = aes(x = get(parameter), y = mean_wolves)) +
    geom_point() +
    geom_smooth(method = 'lm', se = FALSE) +
    theme_minimal() +
    labs(x = parameter, y = 'wolves') +
    facet_grid(~ as.factor(ticks))
  
  p_grass <- ws_summary %>%
    filter(ticks %in% c(50, 100, 250, 500)) %>%
    ggplot(mapping = aes(x = get(parameter), y = mean_grass)) +
    geom_point() +
    geom_smooth(method = 'lm', se = FALSE) +
    theme_minimal() +
    labs(x = parameter, y = 'grass') +
    facet_grid(~ as.factor(ticks))
  
  plot <- p_sheep / p_wolves / p_grass + plot_layout(guides = 'collect')
  
  return(plot)
}
```

1) initial_number_sheep
```{r}
PlotCorrelations('initial_number_sheep')
```

2) initial_number_wolves
```{r}
PlotCorrelations('initial_number_wolves')
```

3) sheep_gain_from_food
```{r}
PlotCorrelations('sheep_gain_from_food')
```

4) wolves_gain_from_food
```{r}
PlotCorrelations('wolves_gain_from_food')
```

5) sheep_reproduce
```{r}
PlotCorrelations('sheep_reproduce')
```

6) wolves_reproduce
```{r}
PlotCorrelations('wolves_reproduce')
```

7) grass_regrowth_time
```{r}
PlotCorrelations('grass_regrowth')
```

# ABM inspection: temporal autcorrelation plots
Compute (partial) autocorrelation for each time series
```{r}
# dataframe to store results
autocorrelation_df <- tibble(combination_number = numeric(),
                              lag = numeric(),
                              acf_sheep = numeric(),
                              pacf_sheep = numeric(),
                              acf_wolves = numeric(),
                              pacf_wolves = numeric(),
                              acf_grass = numeric(),
                              pacf_grass = numeric())

# per time series (parameter set)
for(i in unique(ws_summary$combination_number)){
  select <- ws_summary %>%
    filter(combination_number == i)
  
  # compute acf and pacf
  acfs_sheep <- acf(select$mean_sheep, plot = FALSE,
                    lag.max = 45, type = 'correlation')$acf
  pacfs_sheep <- pacf(select$mean_sheep, plot = FALSE,
                      lag.max = 45)$acf
  acfs_wolves <- acf(select$mean_wolves, plot = FALSE,
                     lag.max = 45, type = 'correlation')$acf
  pacfs_wolves <- pacf(select$mean_wolves, plot = FALSE,
                       lag.max = 45)$acf
  acfs_grass <- acf(select$mean_grass, plot = FALSE,
                    lag.max = 45, type = 'correlation')$acf
  pacfs_grass <- pacf(select$mean_grass, plot = FALSE,
                     lag.max = 45)$acf
  
  # add 0 in front of the pacf series, since they start at lag 1, not 0
  add_df <- tibble(combination_number = rep(i, 46),
                   lag = 0:45,
                   acf_sheep = acfs_sheep,
                   pacf_sheep = c(0, pacfs_sheep),
                   acf_wolves = acfs_wolves,
                   pacf_wolves = c(0, pacfs_wolves),
                   acf_grass = acfs_grass,
                   pacf_grass = c(0, pacfs_grass))
  
  autocorrelation_df <- autocorrelation_df %>%
    add_row(add_df)
}
```
Plot (partial) autocorrelations:
```{r}
acf_sheep <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = acf_sheep,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'autocorrelation sheep') +
  theme_minimal() +
  theme(legend.position = 'none')

pacf_sheep <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = pacf_sheep,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'partial autocorrelation sheep') +
  theme_minimal() +
  theme(legend.position = 'none')

acf_wolves <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = acf_wolves,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'autocorrelation wolves') +
  theme_minimal() +
  theme(legend.position = 'none')

pacf_wolves <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = pacf_wolves,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'partial autocorrelation wolves') +
  theme_minimal() +
  theme(legend.position = 'none')

acf_grass <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = acf_grass,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'autocorrelation grass') +
  theme_minimal() +
  theme(legend.position = 'none')

pacf_grass <- autocorrelation_df %>%
  ggplot(mapping = aes(x = lag, y = pacf_grass,
                       colour = as.factor(combination_number))) +
  geom_line() +
  labs(y = 'partial autocorrelation grass') +
  theme_minimal() +
  theme(legend.position = 'none')

autocorrelation_plot <- (acf_sheep + acf_wolves + acf_grass) / (pacf_sheep + pacf_wolves + pacf_grass)

ggsave(autocorrelation_plot,
       filename = 'figures/wolfsheep_autocorrelation.pdf')
```

# ABM inspection: sensitivity analysis

# Mimic real-world data: introduce random noise
Noise is maximum 20% of the mean output value it is added to (such that smaller values can be as noisy as large ones). How much noise is added is determined by a N(0, 6). 
```{r}
ws_summary <- ws_summary %>%
  rename(sheep = mean_sheep,
         wolves = mean_wolves,
         grass = mean_grass) %>%
  # per parameter combination
  group_by(combination_number) %>%
  # compute mean sheep, grass, wolves over full time series
  mutate(mean_sheep = mean(sheep),
         mean_wolves = mean(wolves),
         mean_grass = mean(grass)) %>%
  # add noise to each value of sheep, grass, and wolves
  rowwise %>%
  mutate(sheep_noise = sheep + mean_sheep * rnorm(n = 1, mean = 0, sd = 6) / 100,
         wolves_noise = wolves + mean_wolves * rnorm(n = 1, mean = 0, sd = 6) / 100,
         grass_noise = grass + mean_grass * rnorm(n = 1, mean = 0, sd = 6) / 100) %>%
  # add a correction for values < 0, since it's in this case not possible for values
  # to be negative
  mutate(sheep_noise = ifelse(sheep_noise < 0, 0, sheep_noise),
         wolves_noise = ifelse(wolves_noise < 0, 0, wolves_noise),
         grass_noise = ifelse(grass_noise < 0, 0, grass_noise))
```
Check that the noise was added properly:
```{r}
# sheep
ws_summary %>%
  ggplot(mapping = aes(x = sheep, y = sheep_noise)) +
  geom_point(alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1,
              colour = 'darkgreen', lty = 2) +
  labs(x = 'sheep original', y = 'sheep noise') +
  theme_minimal()

# wolves
ws_summary %>%
  ggplot(mapping = aes(x = wolves, y = wolves_noise)) +
  geom_point(alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1,
              colour = 'darkgreen', lty = 2) +
  labs(x = 'wolves original', y = 'wolves noise') +
  theme_minimal()

# grass
ws_summary %>%
  ggplot(mapping = aes(x = grass, y = grass_noise)) +
  geom_point(alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1,
              colour = 'darkgreen', lty = 2) +
  labs(x = 'grass original', y = 'grass noise') +
  theme_minimal()
```

# Summarise time series:
Carella 2021 does the following for this model (with 200 time steps):
- value every 50 time steps
- maximum
- minimum
- average
- standard deviation
- trend
I'm going to add an option with
- value every 20 time steps
- maximum
- minimum
- average
- standard deviation
- trend
And an option with
- value every 10 time steps
- maximum
- minimum
- average
- standard deviation
- trend
And also an option where we look at the entire time series
+ looking only at the final time point.

```{r}
ws_summary_timesteps <- ws_summary %>%
  # per parameter combination
  group_by(combination_number) %>%
  # compute min, max, sd, and trend for sheep, grass, wolves over full time series
  # do this for both the clean and the noisy data
  mutate(min_sheep = min(sheep),
         max_sheep = max(sheep),
         sd_sheep = sd(sheep),
         trend_sheep = sens.slope(sheep)$estimates,
         mean_sheep_noise = mean(sheep_noise),
         min_sheep_noise = min(sheep_noise),
         max_sheep_noise = max(sheep_noise),
         sd_sheep_noise = sd(sheep_noise),
         trend_sheep_noise = sens.slope(sheep_noise)$estimates,
         min_wolves = min(wolves),
         max_wolves = max(wolves),
         sd_wolves = sd(wolves),
         trend_wolves = sens.slope(wolves)$estimates,
         mean_wolves_noise = mean(wolves_noise),
         min_wolves_noise = min(wolves_noise),
         max_wolves_noise = max(wolves_noise),
         sd_wolves_noise = sd(wolves_noise),
         trend_wolves_noise = sens.slope(wolves_noise)$estimates,
         min_grass = min(grass),
         max_grass = max(grass),
         sd_grass = sd(grass),
         trend_grass = sens.slope(grass)$estimates,
         mean_grass_noise = mean(grass_noise),
         min_grass_noise = min(grass_noise),
         max_grass_noise = max(grass_noise),
         sd_grass_noise = sd(grass_noise),
         trend_grass_noise = sens.slope(grass_noise)$estimates) %>%
  ungroup() %>%
  # filter out the time steps of interest
  filter(ticks %in% seq(from = 10, to = 500, by = 10))
```
Reshape data
```{r}
# extend all data to 500 ticks

# new data frame to store extended data
ws_summary_timesteps_new <- ws_summary_timesteps[1,]

# per parameter combination
for(i in unique(ws_summary_timesteps$combination_number)){
  # extract data for parameter combination
  work_with <- ws_summary_timesteps %>%
    filter(combination_number == i)
  
  # if data contains less than 500 ticks
  if(max(work_with$ticks) < 500){
    # register last tick included
    max_ticks <- max(work_with$ticks)
    
    # data to extend to 500 ticks
    add_rows <- work_with %>%
      filter(ticks == max_ticks)
    
    # ticks to add
    add_ticks <- seq(from = max_ticks + 10, to = 500, by = 10)
    
    # to store new data
    new_df <- add_rows
    
    # create data frame with last tick data, extending
    # for all required ticks
    for(i in 1:length(add_ticks)){
      new_df <- bind_rows(new_df, add_rows)
    }
    
    # set ticks to run until 500
    new_df$ticks <- c(max_ticks, add_ticks)
    # add original data to extended data
    new_df <- bind_rows(work_with, new_df)
    # to send back to complete dataframe
    work_with <- new_df
  }
  # fill out new data frame with extended data
  # or original data where it didn't need to be extended
  ws_summary_timesteps_new <- bind_rows(ws_summary_timesteps_new, work_with)
}
# remove set-up data row
ws_summary_timesteps_new <- ws_summary_timesteps_new[-1, ] %>%
  distinct()

# pivot wider so that each time step is a data column
# each parameter combination will have 1 row of data
ws_summary_timesteps <- ws_summary_timesteps_new %>%
  filter(ticks %in% seq(from = 10, to = 500, by = 10)) %>%
  pivot_wider(names_from = ticks,
              values_from = c(sheep, wolves, grass,
                              sheep_noise, wolves_noise, grass_noise))
```

Save all data frames:
```{r}
# complete data (for time series analysis)
ws_summary %>%
  write_csv(file = 'data/processed/wolfsheep_timeseries_training.csv')
# time steps
ws_summary_timesteps %>%
  write_csv(file = 'data/processed/wolfsheep_timesteps_training.csv')
```